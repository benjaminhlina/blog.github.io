{
  "hash": "19f72d5cf048bf00a1f6d023787d845c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to use {nichetools} with nicheROVER\"\nauthor: \"Benjamin L. Hlina\"\ndate: \"2024-03-15\"\nimage: \"1_ellipses_density_biplot.png\"\ncategories: [Stable Isotopes, Trophic Dynamics, Food Webs]\neditor_options: \n  chunk_output_type: inline\n\n---\n\n\n### Our Objectives\n\nThe purpose of this vignette is to use [{nicheROVER}](https://cran.r-project.org/web/packages/nicheROVER/index.html) and [{nichetools}](https://benjaminhlina.github.io/nichetools/) to extract and then visualize estimates of trophic niche size and similarities for multiple freshwater fish using [{ggplot2}](https://ggplot2.tidyverse.org/). \n\nThis vignette can be used for additional purposes including estimating niche size and similarities among different groups of aquatic and/or terrestrial species. Furthermore, niche size and similarities for different behaviours exhibited within a population can be made using behavioural data generated from acoustic telemetry (e.g., differences in habitat occupancy).\n\n\n### Bring in trophic niche data\nFirst we will load the necessary packages to preform the analysis and visualization. We will use [{nicheROVER}](https://cran.r-project.org/web/packages/nicheROVER/index.html) and [{nichetools}](https://benjaminhlina.github.io/nichetools/) to preform the analysis. We will use [{dplyr}](https://dplyr.tidyverse.org/), [{tidyr}](https://tidyr.tidyverse.org/), and [{purrr}]() to manipulate data and iterate processes. Lastly, we will use [{ggplot2}](https://ggplot2.tidyverse.org/), [{ggtext}](https://wilkelab.org/ggtext/), and [{patchwork}](https://patchwork.data-imaginist.com/) to plot, add labels, and arrange plots.\n\nI will add that many of the `{dplyr}` and `{tidyr}` functions and processes can be replaced using [{data.table}](https://cran.r-project.org/web/packages/data.table/index.html) which is great when working with large data sets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  library(dplyr)\n  library(ggplot2)\n  library(ggtext)\n  library(ggh4x)\n  library(nicheROVER) \n  library(nichetools)\n  library(patchwork)\n  library(purrr)\n  library(stringr)\n  library(tidyr)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'nichetools' was built under R version 4.4.1\n```\n\n\n:::\n:::\n\n\nFor the purpose of the vignette we will be using the `fish` data frame that is available within `{nicheROVER}`. We will remove $\\delta$<sup>34</sup>S for simplicity of the vignette. If more than two isotopes or metrics are being used to compare niche sizes and similarities, please use the functions for each pairing. Right now some functions (i.e., `niche_ellipse()`) in `{nichetools}` doesn't have the ability to work with more than two isotopes. This will become a feature at some point but for now. Please be patient and use the functions for each pairing you have.\n\nWe will first use the function `janitor::clean_names()` to clean up column names. For your purposes you will need to replace fish with your data frame either by loading a csv, rds, or qs, with your data. You can do this multiple ways, I prefer using `readr::read_csv()` but base R's `read.csv()` works perfectly fine.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- fish %>% \n  janitor::clean_names()\n```\n:::\n\n\nIf there are any isotopic values that did not run and are `NA`, they will need to be removed because `{nicheROVER}`'s functions will not accommodate values of `NA`.\n\n### Estimate posterior distribution with Normal-Inverse-Wishart (NIW) priors.\n\nWe will take 1,000 posterior samples for each group. You can change this but suggest nothing less than 1,000. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsample <- 1000\n```\n:::\n\n\nWe will then split the data frame into a list with each species as a data frame object within the list, We will then iterate over the list, using `map()` from [{purrr}](https://purrr.tidyverse.org/), to estimate posterior distribution using Normal-Inverse-Wishart (NIW) priors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfish_par <- df %>% \n  split(.$species) %>% \n  map(~ select(., d13c, d15n)) %>% \n  map(~ niw.post(nsample = nsample, X = .))\n```\n:::\n\n\n### Extract μ values  \n\nWe will use `extract_mu()`to extract posteriors for $\\mu$ estimates. The default output of `extract_mu()` is long format\nwhich works for plotting with {ggplot2} and other functions in {nichetools}. If we want wide format we can specify the argument `format` with `\"wide\"`, however, it is unlikely you will need this data in wide format. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_mu <- extract_mu(fish_par)\n```\n:::\n\n\nThe default output will be lacking some info for plotting. We will need to add in a column that is the element abbreviation and neutron number to be used in axis labeling. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_mu <- df_mu %>%\n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    ) \n  )\n```\n:::\n\n\n### Extract Σ values \nWe will use `extract_sigma()` to extract posterior estimates for $\\Sigma$. The default output of `extract_sigma()` is wide format which doesn't work for plotting with {ggplot2} but does work other functions in {nichetools}. If we want long for plotting we can specify the argument `format` with `\"long\"`. \n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma <- extract_sigma(fish_par)\n```\n:::\n\n\nFor plotting we will need the extracted $\\Sigma$ values to be in long format. We also  need to remove $\\Sigma$ values for when the both isotope columns are the same isotope. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma_cn <- extract_sigma(fish_par, \n                             data_format = \"long\") %>%\n  filter(id != isotope)\n```\n:::\n\n\n\n### Plot posterior distrubtion of μ and Σ\n\nFor most plotting within this vignette, I will `split()` the data frame by isotope, creating a list that I will then use `imap()` to iterate over the list to create plots. We will use `geom_density()` to represent densities for both $\\mu$ and $\\Sigma$. Plot objects will then be stored in a list. \n\nFirst we will plot $\\mu$ for each isotope. We will use [{patchwork}](https://patchwork.data-imaginist.com/) to configure plots for multi-panel figures. This package is phenomenal and uses math operators to configure and manipulate the plots to create multi-panel figures.\n\nFor labeling we are also going to use `element_markdown()` from [{ggtext}](https://wilkelab.org/ggtext/) to work with the labels that are needed to correctly display the isotopic signature. If you are working other data please replace. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior_plots <- df_mu %>%\n  split(.$isotope) %>%\n  imap(\n    ~ ggplot(data = ., aes(x = mu_est)) +\n      geom_density(aes(fill = sample_name), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\",\n            legend.background = element_blank()\n      ) +\n      labs(\n        x = paste(\"\\u00b5<sub>\\U03B4</sub>\", \"<sub><sup>\",\n                  unique(.$neutron), \"</sup></sub>\",\n                  \"<sub>\",unique(.$element), \"</sub>\", sep = \"\"),\n        y = paste0(\"p(\\u00b5 <sub>\\U03B4</sub>\",\"<sub><sup>\",\n                   unique(.$neutron), \"</sub></sup>\",\n                   \"<sub>\",unique(.$element),\"</sub>\",\n                   \" | X)\"), sep = \"\")\n  )\n\nposterior_plots$d15n +\n  theme(legend.position = c(0.18, 0.82)) + \n  posterior_plots$d13c\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=100%}\n:::\n:::\n\n\n\n\nFor labeling purposes we need to add columns that are the element abbreviation and neutron number. I do this by using `case_when()` which are vectorized if else statements. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma_cn <- df_sigma_cn %>%\n  mutate(\n    element_id = case_when(\n      id == \"d15n\" ~ \"N\",\n      id == \"d13c\" ~ \"C\",\n    ),\n    neutron_id = case_when(\n      id == \"d15n\" ~ 15,\n      id == \"d13c\" ~ 13,\n    ),\n    element_iso = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ),\n    neutron_iso = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    )\n  )\n```\n:::\n\n\nNext we will plot the posteriors for $\\Sigma$.\n\n::: {.cell}\n\n```{.r .cell-code}\nsigma_plots <- df_sigma_cn %>%\n  group_split(id, isotope) %>%\n  imap(\n    ~ ggplot(data = ., aes(x = post_sample)) +\n      geom_density(aes(fill = sample_name), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\"\n      ) +\n      labs(\n        x = paste(\"\\U03A3\",\"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_id), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_id),\"</sub>\",\" \",\n                  \"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_iso), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_iso),\"</sub>\", sep = \"\"),\n        y = paste(\"p(\", \"\\U03A3\",\"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_id), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_id),\"</sub>\",\" \",\n                  \"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_iso), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_iso),\"</sub>\", \" | X)\", sep = \"\"),\n      )\n  )\n\nsigma_plots[[1]] + \n  theme(legend.position = c(0.1, 0.82))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=100%}\n:::\n:::\n\n\n\n### Estimate niche ellipse \n\nWe then will use `niche_ellipse()` to easily extract ellipse for each $\\Sigma$ estimate (i.e., 1000). If you are to have additional isotopes or metrics, you will need to create mu and sigma objects for each pairing, as currently this function only handles two isotopes. In the future, there likely will be the ability to specify the number of isotopes you have with the default being two. The reason for the lack of functionality is `ellipse::ellipse()` can only work within two-dimensions, not three, so you will have to create multiple `ellipse()` calls for each combination of isotopes or metrics and I haven't had the time to implement this. The function will also tell you how long it took to process as with large sets of isotope data it is nice to know the time it takes for the function to work. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nellipse_df <- niche_ellipse(dat_mu = df_mu, dat_sigma = df_sigma)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n→ Total time processing was 0.03 secs\n```\n\n\n:::\n:::\n\n\nWe will randomly sample 10 ellipses out of 1,000. You can change this but this seems pretty standard. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(14)\n\nrandom_ellipse <- ellipse_df %>% \n  group_by(sample_name, sample_number) %>% \n  nest() %>%\n  group_by(sample_name) %>% \n  slice_sample(n = 10, replace = TRUE) %>% \n  ungroup() %>% \n  unnest(cols = c(data))  \n```\n:::\n\n### Plot ellipses, densities of each istope, and isotope biplot \n\nWe will first plot the ellipse for each sample_name \n\n::: {.cell}\n\n```{.r .cell-code}\nellipse_plots <- ggplot() + \n  geom_polygon(data = random_ellipse,\n               mapping = aes(x = d13c, y = d15n,\n                             group = interaction(sample_number, sample_name),\n                             color = sample_name),\n               fill = NA,\n               linewidth = 0.5) + \n  \n  scale_colour_viridis_d(begin = 0.25, end = 0.75, \n                         option = \"D\", name = \"species\",\n  ) + \n  scale_x_continuous(breaks = rev(seq(-20, -40, -2))) +\n  scale_y_continuous(breaks = seq(6, 16, 2)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.title = element_text(hjust = 0.5),\n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n```\n:::\n\nWe need to turn `df` into long format to iterate over using `imap()` to easily create density plots. You will notice that I again use `case_when()` to make columns of element abbreviations and neutron numbers that will be used in plot labeling. \n\n\n::: {.cell}\n\n```{.r .cell-code}\niso_long <- df %>%\n  pivot_longer(cols = -species,\n               names_to = \"isotope\", \n               values_to = \"value\") %>% \n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    )\n  )\n```\n:::\n\n\nWe will then make density plots for each isotope using `geom_density()`\n\n::: {.cell}\n\n```{.r .cell-code}\niso_density <- iso_long %>% \n  group_split(isotope) %>% \n  imap(\n    ~ ggplot(data = .) + \n      geom_density(aes(x = value, \n                       fill = species), \n                   alpha = 0.35, \n                   linewidth = 0.8) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw(base_size = 10) +\n      theme(axis.text = element_text(colour = \"black\"),\n            panel.grid = element_blank(), \n            legend.position = c(0.15, 0.55), \n            legend.background = element_blank(), \n            axis.title.x = element_markdown(family = \"sans\")) + \n      labs(x =  paste(\"\\U03B4\",\n                      \"<sup>\", unique(.$neutron), \"</sup>\",unique(.$element), \n                      sep = \"\"), \n           y = \"Density\")\n  )\n\nd13c_density <- iso_density[[1]] + \n  scale_x_continuous(breaks = rev(seq(-20, -34, -2)),\n                     limits = rev(c(-20, -34)))\n\nd15n_density <- iso_density[[2]] +\n  scale_x_continuous(breaks = seq(5, 15, 2.5), \n                     limits = c(5, 15)) + \n  theme(\n    legend.position = \"none\"\n  )\n```\n:::\n\nLastly we will use `geom_point()` to make isotopic biplot. \n\n::: {.cell}\n\n```{.r .cell-code}\niso_biplot <- ggplot() + \n  geom_point(data = df, aes(x = d13c, y = d15n,\n                            fill = species),\n             shape = 21, colour = \"black\", \n             stroke = 0.8,\n             size = 3, alpha = 0.70) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"species\") +\n  scale_x_continuous(breaks = rev(seq(-20, -39, -1))) +\n  scale_y_continuous(breaks = seq(5, 17, 1)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n```\n:::\n\n\n### Use {patchwork} to make ellipse, density, and biplots into a paneled figure. \n\nWe can also use the function `plot_annotation()` to add lettering to the figure that can be used in the figure description. To maneuver where `plot_annotation()` places the lettering, we need to add `plot.tag.position = c(x, y)` to the `theme()` call in every plot. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd13c_density + ellipse_plots + iso_biplot + d15n_density +\n  plot_annotation(tag_levels = \"a\", \n                  tag_suffix = \")\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=100%}\n:::\n:::\n\n\n### Determine the 95% niche similarties for each species \n\nWe will use the `overlap()` function from [{nicheROVER}](https://cran.r-project.org/web/packages/nicheROVER/index.html) to estimate the percentage of similarity among species. We will set overlap to assess based on 95% similarities. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nover_stat <- overlap(fish_par, nreps = nsample, nprob = 1000, \n                     alpha = 0.95)\n```\n:::\n\n\nWe then are going transform this output to a data frame using `extract_overlap()` plotting so we can assess overall similarities among species. \n\n::: {.cell}\n\n```{.r .cell-code}\nover_stat_df <- extract_overlap(data = over_stat) %>% \n    mutate(\n      niche_overlap_perc = niche_overlap * 100\n  )\n```\n:::\n\n\nWe then are going to take our newly made data frame and extract out the mean percentage of similarities and the 2.5% and 97.5% quarantines. We plot these as lines and dotted lines on our percent similarity density figure. \n\n::: {.cell}\n\n```{.r .cell-code}\nover_sum <- over_stat_df %>% \n  group_by(sample_name_a, sample_name_b) %>% \n  summarise(\n    mean_niche_overlap = round(mean(niche_overlap_perc), digits = 2),\n    qual_2.5 = round(quantile(niche_overlap_perc, probs = 0.025, na.rm = TRUE), digits = 2), \n    qual_97.5 = round(quantile(niche_overlap_perc, probs = 0.975, na.rm = TRUE), digits = 2)\n  ) %>% \n  ungroup() %>% \n  pivot_longer(cols = -c(sample_name_a, sample_name_b, mean_niche_overlap), \n               names_to = \"percentage\", \n               values_to = \"niche_overlap_qual\") %>% \n  mutate(\n    percentage = as.numeric(str_remove(percentage, \"qual_\"))\n  ) \n```\n:::\n\n\nWe are now going to use `ggplot()`, `geom_density()`, and `fact_grid2()` from [{ggh4x}](https://teunbrand.github.io/ggh4x/). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = over_stat_df, aes(x = niche_overlap_perc)) + \n  geom_density(aes(fill = sample_name_a)) + \n  geom_vline(data = over_sum, aes(xintercept = mean_niche_overlap), \n             colour = \"black\", linewidth = 1) +\n  geom_vline(data = over_sum, aes(xintercept = niche_overlap_qual), \n             colour = \"black\", linewidth = 1, linetype = 6) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"Species\", \n                       alpha = 0.35) + \n  facet_grid2(sample_name_a ~ sample_name_b, \n                     independent = \"y\",\n                     scales = \"free_y\") + \n  theme_bw() + \n  theme(\n    panel.grid = element_blank(), \n    axis.text = element_text(colour = \"black\"), \n    legend.background = element_blank(),\n    strip.background = element_blank()\n  ) +\n  labs(x = paste(\"Overlap Probability (%)\", \"\\u2013\", \n                 \"Niche Region Size: 95%\"), \n       y = \"p(Percent Overlap | X)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=100%}\n:::\n:::\n\n\n### Estimate overall niche size \n\nWe are now going to estimate the overall size of the niche for each posterior sample by using the function `extract_niche_size()` which is a wrapper around `niche.size()` and some data manipulation functions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nniche_size <- extract_niche_size(fish_par)\n```\n:::\n\n\nWe can calculate the mean niche size, standard deviation, and standard error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nniche_size_mean <- niche_size %>% \n  group_by(sample_name) %>% \n  summarise(\n    mean_niche = round(mean(niche_size), digits = 2), \n    sd_niche = round(sd(niche_size), digits = 2), \n    sem_niche = round(sd(niche_size) / sqrt(n()), digits = 2)\n  )\n```\n:::\n\n\n### Plot niche size \n\nWe will now use `geom_violin()`, `geom_point()`, and `geom_errorbar()` to plot the distribution for niche size for each species.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = niche_size) + \n  geom_violin(\n    aes(x = sample_name, y = niche_size),\n    width = 0.2) + \n  geom_point(data = niche_size_mean, aes(x = sample_name, y = mean_niche)) +\n  geom_errorbar(data = niche_size_mean, aes(x = sample_name, \n                                            ymin = mean_niche  - sem_niche, \n                                            ymax = mean_niche  + sem_niche), \n                width = 0.05) +\n  theme_bw(base_size = 15) + \n  theme(panel.grid = element_blank(), \n        axis.text = element_text(colour = \"black\")) + \n  labs(x = \"Species\", \n       y = \"Niche Size\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nNow that we have our niche sizes and similarities determined we can make inferences about the species, trophic similarities, and the ecosystem. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}