[
  {
    "objectID": "posts/post-with-code/shortest-path-pathroutr/shortest_path_example_pathroutr.html",
    "href": "posts/post-with-code/shortest-path-pathroutr/shortest_path_example_pathroutr.html",
    "title": "Shortest Paths Within a Boundary - {pathroutr}",
    "section": "",
    "text": "Our Objectives:\nThe purpose of this vignette is to create the shortest distance among acoustic telemetry receivers within a confined boundary such as a lake, river, delta, or oceanscape. This workflow can be adapted to find the distance between any two points within a confined boundary.\nUse this vignette with a bit of caution, as I found some inconsistency with this method when transferring it to other study systems besides this example study system.\nNote, this method differs from the {gdistance} method as we are going to create a network graph to move throughout our study system and determine the shortest path. This vignette will start off the same as the {gdistance} method but will differ when creating the shortest paths.\nYou can download and unzip this vignette using the following code:\n\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/benjaminhlina/shortest_path_example/archive/refs/heads/master.zip\")\n\n\n\nStep 1: Load shapefile and receiver locations\nWe will first load all the packages we need, we will use {pathroutr} to find the shortest paths using {sfnetworks} and {sf} to find the distances of those shortest paths.\n\n# ---- load packages ----\n{\n  library(dplyr)\n  library(ggplot2)\n  library(ggspatial)\n  library(here)\n  library(igraph)\n  library(lwgeom)\n  library(pathroutr)\n  library(purrr)\n  library(readr)\n  library(sf)\n  library(sfnetworks)\n  library(sp)\n  library(tibble)\n  library(tidyr)\n  make_line &lt;- function(lon, lat, llon, llat) {\n    st_linestring(matrix(c(lon, llon, lat, llat), 2, 2))\n  }\n}\n\nWe will bring bring in our shapefile. This vignette will use Big Sissabagama Lake as it is the lake I grew up fishing on in Wisconsin, USA. Please replace with the shapefile of your desired body of water.\n\nlake &lt;- st_read(dsn = here(\"Data\",\n                           \"shapefile\",\n                           \".\"),\n                layer = \"sissabagama_lake\")\n\nImportant that you convert to the correct UTM zone. For the vignette we are using UTM zone 15 N. Adjust your UTM zone accordingly.\n\nlake_utm &lt;- st_transform(lake, crs = 32615)\n\nWe will then bring in our receiver locations. Replace rl_sum_sf with your receiver locations as a RDS or csv file type or whatever you use to document receiver locations.\n\nrl_sum_sf &lt;- read_rds(here(\"Data\",\n                           \"receiver locations\",\n                           \"rl_sum_sf.rds\"))\n\nConvert to UTMs for plotting purposes and make sure you use the correct UTM zone.\n\nrl_sum_utm &lt;- st_transform(rl_sum_sf, crs = 32615)\n\n\n\nStep 2: Invert shapefile for inland lakes and rivers\n{pathroutr} was built with the intent of working on oceanscapes where the shapefile is land. For inland bodies of water the shapefile is usually water, therefore to get {pathroutr} to function we need to invert our inland lake or river shapefile\nFirst we are going to get the extent of our shapefile which will be in UTMs\n\next &lt;- st_bbox(lake_utm, crs = st_crs(lake_utm)) %&gt;%\n  st_as_sfc() %&gt;%\n  st_sf()\n\nWe then will invert our shapefile by using st_difference() from {sf}.\n\ninverse &lt;- st_difference(ext, lake_utm)\n\nWe will check if we have correctly taken the inverse of our lake.\n\nggplot() +\n  geom_sf(data = inverse) + \n  theme_void()\n\n\n\n\nStep 3: Create land region to build our network\nWe need to create a buffered land region to use as a barrier. Within st_buffer() we will need to adjust dist argument to change the buffer distance to be adequate for the study system. For this example we will use 650 m.\n\nland_region &lt;- rl_sum_utm %&gt;% \n  st_buffer(dist = 650) %&gt;%\n  st_union() %&gt;%\n  st_convex_hull() %&gt;% \n  st_intersection(inverse) %&gt;% \n  st_sf()\n\nWe will check if we have correctly buffered our land region\n\nggplot() +\n  geom_sf(data = land_region) + \n  theme_void()\n\n\n\n\nStep 4: Create every combination of paths for every receiver\nFirst we will convert receiver location which is a sf object to a tibble with each location combination.\n\nprep_path &lt;- rl_sum_sf %&gt;%\n  mutate(\n    lon = st_coordinates(.)[,\"X\"],# grab lon\n    lat = st_coordinates(.)[,\"Y\"],# grab lat\n  ) %&gt;%  \n  st_drop_geometry() %&gt;% # drop sf \n  # once geometry removed create to and from lat longs \n  mutate(llon = lon,\n         llat = lat,\n         lonlat = paste0(lon, \",\", lat),\n         llonllat = paste0(llon, \",\", llat)) %&gt;%\n  dplyr::select(-lon, -lat, -llon, -llat) %&gt;%\n  expand(lonlat, llonllat) %&gt;% # expand for each to and from combo \n  separate(lonlat, c(\"lon\", \"lat\"), \",\") %&gt;%\n  separate(llonllat, c(\"llon\", \"llat\"), \",\") %&gt;%\n  mutate_if(is.character, function(x) as.numeric(x)) \n\nprep_path has all of the path combinations but we lose the names of the receivers and which paths go from one receiver to another. We are going to add that information back in by creating an object called rec_order\n\nrec_order &lt;- prep_path %&gt;%\n  left_join(\n    rl_sum_sf %&gt;% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"], \n        lat = st_coordinates(.)[,\"Y\"]\n      ) %&gt;% \n      st_drop_geometry() %&gt;% \n      rename(from = rec_name) %&gt;% \n      select(from, lon, lat), by = c(\"lon\", \"lat\"), \n    multiple = \"all\"\n  ) %&gt;%  \n  left_join(\n    rl_sum_sf %&gt;% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"]\n      ) %&gt;% \n      st_drop_geometry() %&gt;% \n      rename(to = rec_name,\n             llon = lon) %&gt;% \n      select(to, llon), by = c(\"llon\"), \n    multiple = \"all\"\n  ) %&gt;% \n  mutate(\n    from_to = paste0(from, \"-\", to)\n  ) %&gt;% \n  select(from, to, from_to, lon, lat, llon, llat)\n\nAwesome! We have all of our combinations with their names and we now know which paths go from one receiver to another. Now we need to make each combination a linestring that we will sample points from to reroute.\nBe sure to choose the correct UTM zone here. This vignette uses UTM zone 15 north but for other uses you will have to change the UTM zone.\n\npath &lt;- prep_path %&gt;%\n  pmap(make_line) %&gt;%\n  st_as_sfc(crs = 4326) %&gt;%\n  st_sf() %&gt;%  \n  mutate(\n    lon = st_startpoint(.) %&gt;%\n      st_coordinates(.) %&gt;%\n      as_tibble() %&gt;%\n      .$X,\n    llon = st_endpoint(.) %&gt;%\n      st_coordinates(.) %&gt;%\n      as_tibble() %&gt;%\n      .$X\n  ) %&gt;% \n  left_join( rec_order %&gt;%\n               select(from:lon, llon),\n             by = c(\"lon\", \"llon\")\n  ) %&gt;%\n  select(from:from_to) %&gt;% \n  st_transform(crs = 32615) %&gt;% \n  arrange(from, to)\n\n\n\nStep 5: sample points along path for {pathroutr} to reroute\nNow that we have our paths we need to sample along the LINESTRING to get paths to reroute. I choose to have a sample distance of 5 m but you can change this depending on the study site.\nWe need to cast our sampled points as MULTIPOINT object for {pathroutr} to sample\n\npath_pts &lt;- path %&gt;% \n  st_segmentize(dfMaxLength = units::set_units(5, m)) %&gt;% \n  st_cast(\"MULTIPOINT\")\n\nImportant note, sometimes this sampling step results in points that intersect with the boundary of your land region which may cause issues with {pathroutr}. To fix this you will need to use the following code:\n\npath_pts_fix &lt;- prt_trim(trkpts = path_pts, barrier = land_region)\n\nThough for this vignette we will not use path_pts_fix.\nWe are going to visualize our paths, we could visualize the path_pts but this often takes awhile to process as the sample interval is 5 m and path_pts will be taken from our paths\n\nggplot() + \n  geom_sf(data = land_region)  +\n  geom_sf_label(data = rl_sum_sf, aes(label = rec_name), \n                size = 4) +\n  geom_sf(data = path, linewidth = 1) + \n  theme_void()\n\n\n\n\nStep 6: Use get_barrier_segments from {pathroutr} to id path points that travel across landmasses in our lake.\n\nlake_bar_seg &lt;- get_barrier_segments(trkpts = path_pts,\n                                     barrier =  land_region)\n\n\n\nStep 7: Create network graph in our study system\nCreate a network graph that is bound by land_region and made up Delaunay triangles which are created in theory by looking from one point on one shore to directly across the study system until you hit a land object.\n\nvis &lt;- prt_visgraph(barrier = land_region)\n\nWe can manipulate our network graph in several ways, the first is supplying the argument aug_points with the receiver location sf object. By doing so we add in triangles that will directly go to our receiver locations. However if you want to use this feature please install the forked version of {pathroutr} using the following code, as the original source currently does not support this feature.\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"benjaminhlina/pathroutr\")\n\nSecondly, we can use the argument centroids to add additional points within our network.\nLastly, we can use the argument buffer to have paths be buffered from our land masses by a given distance in metres. We can visualize our network by first using the function activate from {sfnetworks}.\n\nvis_graph_sf &lt;- activate(vis, \"edges\") %&gt;% \n  st_as_sf()\n\nggplot() + \n  geom_sf(data = vis_graph_sf) + \n  theme_void()\n\n\n\n\nStep 8: Create rerouted sections\nUsing prt_shortestpath we will reroute sections that go across land using our created network.\n\nsegs_tbl &lt;- prt_shortpath(lake_bar_seg, vis, blend = TRUE)\n\nWe can visualize these rerouted paths\n\nggplot() + \n  geom_sf(data = land_region, size = 0) +\n  layer_spatial(data = segs_tbl$geometry, \n                color = \"deepskyblue3\",\n                linewidth = 1) +\n  theme_void()\n\n\n\n\nStep 9: Update our paths to not travel across land\n\ntrack_pts_fix &lt;- prt_reroute(path_pts, land_region, vis)\n\ntrack_pts_fix &lt;- prt_update_points(track_pts_fix, path_pts)\n\n\n\nStep 10: Convert points to linestrings to determine distance\n\ntrack_pts_fixed &lt;- track_pts_fix %&gt;% \n  group_by(from_to) %&gt;% \n  summarise(do_union = FALSE) %&gt;% \n  st_cast('LINESTRING') %&gt;%  \n  ungroup() %&gt;% \n  separate(from_to, into = c(\"from\", \"to\"), sep = \"-\", \n           remove = FALSE) %&gt;% \n  mutate(\n    cost_dist_m = as.numeric(st_length(.))\n  ) %&gt;% \n  filter(from != to) %&gt;% \n  dplyr::select(from, to, from_to, cost_dist_m, geometry)\n\n\n\nStep 11: Visualize our paths\nFirst we will check if one route rerouted properly\n\n# view one reroute to confirm pathroutr is rerouting \ntrack_pts_fixed %&gt;% \n  filter(from_to == \"15-11\") %&gt;% \n  ggplot() + \n  geom_sf(data = land_region, size = 0) +\n  geom_sf(color = \"deepskyblue3\", \n          linewidth = 1) +\n  theme_void()\n\n\nNext we will visualize the whole network and have colour be our distances\n\nggplot() + \n  geom_sf(data = lake_utm, colour = \"black\",\n          size = 1) +\n  geom_sf(data = rl_sum_utm, \n          size = 4, colour = \"black\") + \n  geom_sf(data = track_pts_fixed, \n          aes(color = cost_dist_m), \n          linewidth = 1) +\n  scale_colour_viridis_c(option = \"D\", \n                         name = \"Cost Distance (m)\") + \n  theme_void()"
  },
  {
    "objectID": "posts/post-with-code/nicheROVER-ggplot/index.html",
    "href": "posts/post-with-code/nicheROVER-ggplot/index.html",
    "title": "Estimating Trophic Niches - {nicheROVER} and {ggplot2}",
    "section": "",
    "text": "Our Objectives:\nThe purpose of this vignette is to use {ggplot2} to visualize estimates of trophic niche size and similarities for multiple freshwater fish.\nThis vignette can be used for additional purposes including estimating niche size and similarities among different groups of aquatic and/or terrestrial species. Furthermore, niche size and similarities for different behaviours exhibited within a population can be made using behavioural data generated from acoustic telemetry (e.g., differences in habitat occupancy).\nYou can download and unzip this vignette using the following code:\n\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/benjaminhlina/nicheROVER-ggplot-vignette/archive/refs/heads/main.zip\")\n\n\n\nStep 1: Bring in trophic niche data\nFirst we will load the necessary packages to preform the analysis and visualization. We will use {nicheROVER} and {ellipse} to preform the analysis. We will use {dplyr}, {purrr}, and {tidyr} to manipulate data and iterate processes. Lastly, we will use {ggplot2}, {ggtext}, and {patchwork} to plot, add labels and arrange plots.\nI will add that many of the {dplyr} and {tidyr} functions and processes can be replaced using {data.table} which is great when working with large datasets.\n\n{\n  library(dplyr)\n  library(ellipse)\n  library(ggplot2)\n  library(ggtext)\n  library(here)\n  library(nicheROVER) \n  library(purrr)\n  library(patchwork)\n  library(readr)\n  library(stringr)\n  library(tidyr)\n}\n\nFor the purpose of the vignette we will be using the fish dataframe that is available within {nicheROVER}. We will remove \\(\\delta\\)34S for simplicity of the vignette. If more than two isotopes or metrics are being used to compare niche size and overlap, you can make modify the code to include the additional isotopes or metrics.\nWe will first use the function janitor::clean_names() to clean up column names and remove \\(\\delta\\)34S column. For your purposes you will need to replace fish with your dataframe either by loading a csv or rds with your data. You can do this multiple ways, I prefer using readr::read_csv() but base R works perfectly fine.\n\ndf &lt;- fish %&gt;% \n  janitor::clean_names() %&gt;% \n  select(-d34s)\n\nIf there are any isotopic values that did not run and are NA, they will need to be removed because {nicheROVER}’s functions will not accommodate values of NA.\n\n\nStep 2: Estimate posterior distribution with Normal-Inverse-Wishart (NIW) priors.\nWe will take 1,000 posterior samples for each group. You can change this but suggest nothing less than 1,000.\n\nnsample &lt;- 1000\n\nWe wlll then split the dataframe into a list with each species as a dataframe object within the list, We will then iterate over the list, using map() from {purrr}, to estimate posterior distribution using Normal-Inverse-Wishart (NIW) priors.\n\nfish_par &lt;- df %&gt;% \n  split(.$species) %&gt;% \n  map(~ select(., d15n, d13c)) %&gt;% \n  map(~niw.post(nsample = nsample, X = .))\n\n\n\nStep 3: Extract \\(\\mu\\) values from list object containing posteriors\nWe will use a combination of map() and pluck() to first extract the list of posteriors for \\(\\mu\\). We will extract each vector object for \\(\\mu\\) of each species using imap() and convert them into a tibble.\nWe then will merge each \\(\\mu\\) dataframe together for each species using bind_rows(). We will add species and sample_number back into the dataframe.\n\ndf_mu &lt;- map(fish_par, pluck, 1) %&gt;% \n  imap(~ as_tibble(.x) %&gt;% \n         mutate( \n           metric = \"mu\", \n           species = .y\n         )\n  ) %&gt;%\n  bind_rows() %&gt;% \n  mutate(\n    species = factor(species, \n                     levels = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\"))\n  ) %&gt;% \n  group_by(species) %&gt;% \n  mutate(\n    sample_number = 1:1000\n  ) %&gt;% \n  ungroup()\n\nWe need to manipulate df_mu into long instead of wide format for the rest of the analysis. We will also add in a column that is the element abbreviation and neutron number to be used in axis labeling.\n\ndf_mu_long &lt;- df_mu %&gt;% \n  pivot_longer(cols = -c(metric, species, sample_number), \n               names_to = \"isotope\", \n               values_to = \"mu_est\") %&gt;% \n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    ) \n  )\n\n\n\nStep 4: Extract \\(\\Sigma\\) values from list object containing posteriors\nWe will use a combination of map() and pluck() to first extract the list of posteriors for \\(\\Sigma\\). We will extract each vector object from each the \\(\\Sigma\\) of each species using imap() and convert them into a tibble.\nWe will manipulate df_sigma from wide to long format. When doing so we create two columns, id and isotope, that identify the two isotopes that \\(\\Sigma\\) is being estimated for.\n\ndf_sigma &lt;- map(fish_par, pluck, 2) %&gt;%\n  imap(~ as_tibble(.x) %&gt;%\n         mutate(\n           metric = \"sigma\",\n           id = c(\"d15n\", \"d13c\"),\n           species = .y\n         )\n  ) %&gt;%\n  bind_rows() %&gt;%\n  pivot_longer(cols = -c(\"id\", \"species\", \"metric\"),\n               names_to = \"isotope\",\n               values_to = \"post_sample\"\n  )  %&gt;%\n  separate(isotope, into = c(\"isotopes\", \"sample_number\"), sep = \"\\\\.\")\n\nWe then need to remove \\(\\Sigma\\) values for when the two columns are the same isotope.\n\ndf_sigma_cn &lt;- df_sigma %&gt;%\n  filter(id != isotopes)\n\n\n\nStep 5: Plot posterior distrubtion of \\(\\mu\\) and \\(\\Sigma\\) using {ggplot2}\nFor most plotting within this vignette, I will split() the dataframe by isotope, creating a list that I will then use imap() to iterate over the list to create plots. We will use geom_density() to represent densities for both \\(\\mu\\) and \\(\\Sigma\\). Plot objects will then be stored in a list.\nFirst we will plot \\(\\mu\\) for each isotope. We will use {patchwork} to configure plots for multi-panel figures. The package is phenomenal and uses math operators to configure and manipulate the plots to create multi-panel figures.\nFor labeling we are also going to use element_markdown() from {ggtext} to work with the labels that are needed to correctly display the isotopic signature. If you are working other data please replace.\n\nposterior_plots &lt;- df_mu_long %&gt;%\n  split(.$isotope) %&gt;%\n  imap(\n    ~ ggplot(data = ., aes(x = mu_est)) +\n      geom_density(aes(fill = species), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\"\n      ) +\n      labs(\n        x = paste(\"\\u00b5&lt;sub&gt;\\U03B4&lt;/sub&gt;\", \"&lt;sub&gt;&lt;sup&gt;\",\n                  unique(.$neutron), \"&lt;/sup&gt;&lt;/sub&gt;\",\n                  \"&lt;sub&gt;\",unique(.$element), \"&lt;/sub&gt;\", sep = \"\"),\n        y = paste0(\"p(\\u00b5 &lt;sub&gt;\\U03B4&lt;/sub&gt;\",\"&lt;sub&gt;&lt;sup&gt;\",\n                   unique(.$neutron), \"&lt;/sub&gt;&lt;/sup&gt;\",\n                   \"&lt;sub&gt;\",unique(.$element),\"&lt;/sub&gt;\",\n                   \" | X)\"), sep = \"\")\n  )\n\nposterior_plots$d15n +\n  theme(legend.position = c(0.18, 0.84)) + \n  posterior_plots$d13c\n\n\n\n\nFor labeling purposes we need to add columns that are the element abbreviation and neutron number. I do this by using case_when() which are vectorized if else statements.\n\ndf_sigma_cn &lt;- df_sigma_cn %&gt;%\n  mutate(\n    element_id = case_when(\n      id == \"d15n\" ~ \"N\",\n      id == \"d13c\" ~ \"C\",\n    ),\n    neutron_id = case_when(\n      id == \"d15n\" ~ 15,\n      id == \"d13c\" ~ 13,\n    ),\n    element_iso = case_when(\n      isotopes == \"d15n\" ~ \"N\",\n      isotopes == \"d13c\" ~ \"C\",\n    ),\n    neutron_iso = case_when(\n      isotopes == \"d15n\" ~ 15,\n      isotopes == \"d13c\" ~ 13,\n    )\n  )\n\nNext we will plot the posteriors for \\(\\Sigma\\).\n\nsigma_plots &lt;- df_sigma_cn %&gt;%\n  group_split(id, isotopes) %&gt;%\n  imap(\n    ~ ggplot(data = ., aes(x = post_sample)) +\n      geom_density(aes(fill = species), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\"\n      ) +\n      labs(\n        x = paste(\"\\U03A3\",\"&lt;sub&gt;\\U03B4&lt;/sub&gt;\",\n                  \"&lt;sub&gt;&lt;sup&gt;\", unique(.$neutron_id), \"&lt;/sub&gt;&lt;/sup&gt;\",\n                  \"&lt;sub&gt;\",unique(.$element_id),\"&lt;/sub&gt;\",\" \",\n                  \"&lt;sub&gt;\\U03B4&lt;/sub&gt;\",\n                  \"&lt;sub&gt;&lt;sup&gt;\", unique(.$neutron_iso), \"&lt;/sub&gt;&lt;/sup&gt;\",\n                  \"&lt;sub&gt;\",unique(.$element_iso),\"&lt;/sub&gt;\", sep = \"\"),\n        y = paste(\"p(\", \"\\U03A3\",\"&lt;sub&gt;\\U03B4&lt;/sub&gt;\",\n                  \"&lt;sub&gt;&lt;sup&gt;\", unique(.$neutron_id), \"&lt;/sub&gt;&lt;/sup&gt;\",\n                  \"&lt;sub&gt;\",unique(.$element_id),\"&lt;/sub&gt;\",\" \",\n                  \"&lt;sub&gt;\\U03B4&lt;/sub&gt;\",\n                  \"&lt;sub&gt;&lt;sup&gt;\", unique(.$neutron_iso), \"&lt;/sub&gt;&lt;/sup&gt;\",\n                  \"&lt;sub&gt;\",unique(.$element_iso),\"&lt;/sub&gt;\", \" | X)\", sep = \"\"),\n      )\n  )\n\nsigma_plots[[1]] + \n  theme(legend.position = c(0.1, 0.82))\n\n\n\n\n\n\nStep 6: Estimate niche ellipse\nWe need to manipulate df_sigma back to wide format for ellipses.\n\ndf_sigma_wide &lt;- df_sigma %&gt;%\n  pivot_wider(names_from = id,\n              values_from = post_sample)\n\nNext we will use a for loop to estimate niche ellipses for all 1,000 samples. The default confidence level is 0.95 but can be adjusted by changing p.ell.\n\np.ell &lt;- 0.95\n\nWe will then create a vector of unique species (i.e., groups), that we loop over.\n\nspecies_name &lt;- unique(df_sigma_wide$species)\n\nNext create an empty list to dump the results of the for loop.\n\nall_ellipses &lt;- list()\n\nWe then will use the following for loop. First it subsets mu and sigma objects by species. Then it extracts \\(\\mu\\) and \\(\\Sigma\\) values for each sample number for each isotope and each species. Then \\(\\mu\\) and \\(\\Sigma\\) are given to ellipse() from {ellipse} that will generate a unique ellipse with a confidence interval of p.ell for each sample (e.g., 1,000 samples). We need to add in dummy variables (ell and post.id) in the first loop that we will add to within the second loop.\nIf you are to have additional isotopes or metrics, you will need to modify this loop to include them. Specifically ellipse() can only work within two-dimensions, not three so you will have to create multiple ellipse() calls for each combination of isotopes or metrics.\n\nfor (i in 1:length(species_name)) {\n  \n  sigma_species &lt;- df_sigma_wide %&gt;% \n    filter(species %in% species_name[i])\n  \n  mu_species &lt;- df_mu %&gt;% \n    filter(species %in% species_name[i])\n  \n  ell &lt;- NULL\n  post.id &lt;- NULL\n  \n  for(j in 1:length(unique(sigma_species$sample_number))) {\n    \n    sigma_ind &lt;- sigma_species %&gt;%\n      filter(sample_number %in% sample_number[j]) %&gt;% \n      dplyr::select(d15n, d13c) \n    \n    Sigma &lt;- as.matrix(sigma_ind, 2, 2)\n    row.names(Sigma) &lt;- c(\"d15n\", \"d13c\")\n    \n    mu &lt;- mu_species %&gt;%\n      filter(sample_number %in% sample_number[j]) %&gt;% \n      dplyr::select(sample_number, d15n, d13c) %&gt;% \n      pivot_longer(cols = -sample_number, \n                   names_to = \"isotope\", \n                   values_to = \"mu\") %&gt;% \n      .$mu\n    \n    out &lt;- ellipse::ellipse(Sigma, centre = mu, which = c(1, 2), level = p.ell)\n    \n    ell &lt;- rbind(ell, out)\n    post.id &lt;- c(post.id, rep(j, nrow(out)))\n  }\n  ell &lt;- as.data.frame(ell)\n  ell$rep &lt;- post.id\n  all_ellipses[[i]] &lt;- ell\n}\n\nWe then will then take the resulting list and merge together to create a dataframe that can be used in plotting. I use the argument .id to designate a unique number to each object in the list because each dataframe object in the list is estimated ellipses for each species (e.g., 1-4). we then will use case_when() to add in a column with our species identifiers.\n\n# combine ellipose list into dataframe and add species names back in \nellipse_df &lt;- bind_rows(all_ellipses, .id = \"id\") %&gt;% \n  mutate(\n    species = factor(\n      case_when(\n        id == \"1\" ~ \"ARCS\",\n        id == \"2\" ~ \"BDWF\",\n        id == \"3\" ~ \"LKWF\",\n        id == \"4\" ~ \"LSCS\",\n      ), level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\")\n    )\n  ) %&gt;% \n  as_tibble()\n\nWe will randomly sample 10 ellipses out of 1000. You can change this but this seems pretty standard.\n\nellipse_df %&gt;% \n  group_by(species, rep) %&gt;% \n  nest() %&gt;%\n  group_by(species) %&gt;% \n  slice_sample(n = 10, replace = TRUE) %&gt;% \n  ungroup() %&gt;% \n  unnest(cols = c(data)) -&gt; random_ellipse \n\n\n\nStep 7: Plot ellipses, densities of each istope, and isotope biplot\nWe will first plot the ellipse for each species\n\nellipse_plots &lt;- ggplot() + \n  geom_polygon(data = random_ellipse,\n               mapping = aes(x = d13c, y = d15n,\n                             group = interaction(rep, species),\n                             color = species),\n               fill = NA,\n               linewidth = 0.5) + \n  \n  scale_colour_viridis_d(begin = 0.25, end = 0.75, \n                         option = \"D\", name = \"species\",\n  ) + \n  scale_x_continuous(breaks = rev(seq(-20, -40, -2))) +\n  scale_y_continuous(breaks = seq(6, 16, 2)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.title.align = 0.5,\n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n\nWe need to turn df into long format to iterate over using imap() to easily create density plots. You will notice that I again use case_when() to make columns of elment abbrevations and neutron numbers that will be used in plot labelling.\n\niso_long &lt;- df %&gt;%\n  pivot_longer(cols = -species,\n               names_to = \"isotope\", \n               values_to = \"value\") %&gt;% \n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    )\n  )\n\nWe will then make density plots for each isotope using geom_density()\n\niso_density &lt;- iso_long %&gt;% \n  group_split(isotope) %&gt;% \n  imap(\n    ~ ggplot(data = .) + \n      geom_density(aes(x = value, \n                       fill = species), \n                   alpha = 0.35, \n                   linewidth = 0.8) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw(base_size = 10) +\n      theme(axis.text = element_text(colour = \"black\"),\n            panel.grid = element_blank(), \n            legend.position = c(0.15, 0.65), \n            legend.title.align = 0.5,\n            legend.background = element_blank(), \n            axis.title.x = element_markdown(family = \"sans\")) + \n      labs(x =  paste(\"\\U03B4\",\n                      \"&lt;sup&gt;\", unique(.$neutron), \"&lt;/sup&gt;\",unique(.$element), \n                      sep = \"\"), \n           y = \"Density\")\n  )\n\nd13c_density &lt;- iso_density[[1]] + \n  scale_x_continuous(breaks = rev(seq(-20, -34, -2)),\n                     limits = rev(c(-20, -34)))\n\nd15n_density &lt;- iso_density[[2]] +\n  scale_x_continuous(breaks = seq(5, 15, 2.5), \n                     limits = c(5, 15)) + \n  theme(\n    legend.position = \"none\"\n  )\n\nLastly we will use geom_point() to make isotopic biplot.\n\niso_biplot &lt;- ggplot() + \n  geom_point(data = df, aes(x = d13c, y = d15n,\n                            fill = species),\n             shape = 21, colour = \"black\", \n             stroke = 0.8,\n             size = 3, alpha = 0.70) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"species\") +\n  scale_x_continuous(breaks = rev(seq(-20, -39, -1))) +\n  scale_y_continuous(breaks = seq(5, 17, 1)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.title.align = 0.5,\n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n\n\n\nStep 8: Use {patchwork} to make ellipse, density, and biplots into a paneled figure.\nWe can also use the function plot_annotation() to add lettering to the figure that can be used in the figure description. To maneuver where plot_annotation() places the lettering, we need to add plot.tag.position = c(x, y) to the theme() call in every plot.\n\nd13c_density + ellipse_plots + iso_biplot + d15n_density +\n  plot_annotation(tag_levels = \"a\", \n                  tag_suffix = \")\")\n\n\n\n\n\n\nStep 9: Determine the 95% niche similarties for each species\nWe will use the overlap() function from {nicheROVER} to estimate the percentage of similarty among species. We will set overlap to assess based on 95% similarities.\n\nover_stat &lt;- overlap(fish_par, nreps = nsample, nprob = 1000, \n                     alpha = 0.95)\n\nWe then are going transform this output to a data frame and make the data frame long format for plotting so we can assess overall similarities among species.\n\nover_stat_df &lt;- over_stat %&gt;% \n  as_tibble(rownames = \"species_a\") %&gt;% \n  mutate(\n    id = 1:nrow(.), \n    species_a = factor(species_a, \n                       level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\"))\n  ) %&gt;% \n  pivot_longer(cols = -c(id, species_a), \n               names_to = \"species_b\", \n               values_to = \"mc_nr\")  %&gt;% \n  separate(species_b, into = c(\"species_c\", \"sample_number\"), \n           sep = \"\\\\.\") %&gt;% \n  select(-id) %&gt;% \n  rename(species_b = species_c) %&gt;% \n  mutate(\n    species_b =  factor(species_b, \n                        level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\")\n                        ), \n    mc_nr_perc = mc_nr * 100\n  )\n\nWe then are going to take our newly made data frame and extract out the mean percentage of similarities and the 2.5% and 97.5% quarantines. We plot these as lines and dotted lines on our percent similarty density figure.\n\nover_sum &lt;- over_stat_df %&gt;% \n  group_by(species_a, species_b) %&gt;% \n  summarise(\n    mean_mc_nr = round(mean(mc_nr_perc), digits = 2),\n    qual_2.5 = round(quantile(mc_nr_perc, probs = 0.025, na.rm = TRUE), digits = 2), \n    qual_97.5 = round(quantile(mc_nr_perc, probs = 0.975, na.rm = TRUE), digits = 2)\n  ) %&gt;% \n  ungroup() %&gt;% \n  pivot_longer(cols = -c(species_a, species_b, mean_mc_nr), \n               names_to = \"percentage\", \n               values_to = \"mc_nr_qual\") %&gt;% \n  mutate(\n    percentage = as.numeric(str_remove(percentage, \"qual_\"))\n  ) \n\nWe are now going to use ggplot(), geom_density(), and fact_grid2() from {ggh4x}.\n\nggplot(data = over_stat_df, aes(x = mc_nr_perc)) + \n  geom_density(aes(fill = species_a)) + \n  geom_vline(data = over_sum, aes(xintercept = mean_mc_nr), \n             colour = \"black\", linewidth = 1) +\n  geom_vline(data = over_sum, aes(xintercept = mc_nr_qual), \n             colour = \"black\", linewidth = 1, linetype = 6) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"Species\", \n                       alpha = 0.35) + \n  ggh4x::facet_grid2(species_a ~ species_b, \n                     independent = \"y\",\n                     scales = \"free_y\") + \n  theme_bw() + \n  theme(\n    panel.grid = element_blank(), \n    axis.text = element_text(colour = \"black\"), \n    legend.background = element_blank(),\n    strip.background = element_blank()\n  ) +\n  labs(x = paste(\"Overlap Probability (%)\", \"\\u2013\", \n                 \"Niche Region Size: 95%\"), \n       y = \"p(Percent Overlap | X)\")\n\n\n\n\n\n\nStep 10: Estimate overall niche size\nWe are now going to estimate the overall size of the niche for each posterior sample by using the function niche.size().\n\nniche_size &lt;- sapply(fish_par, function(spec) {\n  apply(spec$Sigma, 3, niche.size)\n})\n\nWe then need to transform niche_size into a data fame for visualization and summary statistics.\n\nniche_size_df &lt;- niche_size %&gt;% \n  as_tibble() %&gt;% \n  mutate(\n    id = 1:nrow(.)\n  ) %&gt;% \n  pivot_longer(\n    cols = -id, \n    names_to = \"species\", \n    values_to = \"niche_size\"\n  ) %&gt;% \n  mutate(\n    id = 1:nrow(.), \n    species = factor(species,\n                   level = c(\"ARCS\", \"BDWF\", \n                             \"LKWF\", \"LSCS\"))\n  )\n\nWe can calculate the mean niche size, standard deviation, and standard error.\n\nniche_size_mean &lt;- niche_size_df %&gt;% \n  group_by(species) %&gt;% \n  summarise(\n    mean_niche = round(mean(niche_size), digits = 2), \n    sd_niche = round(sd(niche_size), digits = 2), \n    sem_niche = round(sd(niche_size) / sqrt(n()), digits = 2)\n  )\n\n\n\nStep 11: Plot niche size with {ggplot}\nWe will now use geom_violin(), geom_point() and geom_errorbar() to plot the distrubition for niche size for each species.\n\nggplot(data = niche_size_df) + \n  geom_violin(\n    aes(x = species, y = niche_size),\n    width = 0.2) + \n  geom_point(data = niche_size_mean, aes(x = species, y = mean_niche)) +\n  geom_errorbar(data = niche_size_mean, aes(x = species, \n                                            ymin = mean_niche  - sem_niche, \n                                            ymax = mean_niche  + sem_niche), \n                width = 0.05) +\n  theme_bw(base_size = 15) + \n  theme(panel.grid = element_blank(), \n        axis.text = element_text(colour = \"black\")) + \n  labs(x = \"Species\", \n       y = \"Niche Size\") \n\n\n\n\nNow that we have our niche sizes determined we can make inferences about the species, trophic similarities, and the ecosystem."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Estimating Trophic Niches - {nicheROVER} and {ggplot2}\n\n\n\n\n\n\n\nStable Isotopes\n\n\nTrophic Dynamics\n\n\nFood Webs\n\n\n\n\n\n\n\n\n\n\n\nAug 4, 2023\n\n\nBenjamin Hlina\n\n\n\n\n\n\n  \n\n\n\n\nShortest Paths Within a Boundary - {pathroutr}\n\n\n\n\n\n\n\nSpatial Analysis\n\n\nTelemetry\n\n\nMovement\n\n\n\n\n\n\n\n\n\n\n\nMay 28, 2023\n\n\nBenjamin Hlina\n\n\n\n\n\n\n  \n\n\n\n\nShortest Paths Within a Boundary - {gdistance}\n\n\n\n\n\n\n\nSpatial Analysis\n\n\nTelemetry\n\n\nMovement\n\n\n\n\n\n\n\n\n\n\n\nMay 26, 2023\n\n\nBenjamin Hlina\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a fisheries scientist and programmer currently based at the Fish Ecology and Conservation Physiology Laboratory, Carleton University, Ottawa, ON, CA. This blog is an extension of my website and is where I host vignettes on a wide range of topics mostly focused on data applications for aquatic scientist."
  },
  {
    "objectID": "posts/post-with-code/shortest-path-gidstance/shortest_path_example_gdistance.html",
    "href": "posts/post-with-code/shortest-path-gidstance/shortest_path_example_gdistance.html",
    "title": "Shortest Paths Within a Boundary - {gdistance}",
    "section": "",
    "text": "Our Objectives:\nThe purpose of this vignette is to create the shortest distance among acoustic telemetry receivers within a confined boundary such as a lake, river, delta, or oceanscape. This workflow can be adapted to find the distance between any two points within a confined boundary.\nYou can download and unzip this vignette using the following code:\n\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/benjaminhlina/shortest_path_example/archive/refs/heads/master.zip\")\n\n\n\nStep 1: Load shapefile and receiver locations\nWe will first load all the packages we need, we will use {gdistance} to find the shortest paths, {sf} to find the distances of those shortest paths.\n\n# ---- load packages ----\n{\n  library(dplyr)\n  library(gdistance)\n  library(ggplot2)\n  library(here)\n  library(purrr)\n  library(raster)\n  library(readr)\n  library(sf)\n  library(sp)\n  library(tibble)\n  library(tidyr)\n  make_line &lt;- function(lon, lat, llon, llat) {\n    st_linestring(matrix(c(lon, llon, lat, llat), 2, 2))\n  }\n}\n\nWe will bring bring in our shapefile. This vignette will use Big Sissabagama Lake as it is the lake I grew up fishing on in Wisconsin, USA. Please replace with the shapefile of your desired body of water.\n\nlake &lt;- st_read(dsn = here(\"Data\",\n                           \"shapefile\",\n                           \".\"),\n                layer = \"sissabagama_lake\")\n\nImportant that you convert to the correct UTM zone. For the vignette we are using UTM zone 15 N. Adjust your UTM zone accordingly.\n\nlake_utm &lt;- st_transform(lake, crs = 32615)\n\nCreate SpatialPloygonDataFrame we will use it to create a raster that will be a transition layer for paths to move across. We will use lake_utm as we need our raster layer in UTMs.\n\nlake_spd &lt;- as_Spatial(lake_utm)\n\nWe will then bring in our receiver locations. Replace rl_sum_sf with your receiver locations as a RDS or csv file type or whatever you use to document receiver locations.\n\nrl_sum_sf &lt;- read_rds(here(\"Data\",\n                           \"receiver locations\",\n                           \"rl_sum_sf.rds\"))\n\nConvert to UTMs for plotting purposes and make sure you use the correct UTM zone.\n\nrl_sum_utm &lt;- st_transform(rl_sum_sf, crs = 32615)\n\n\n\nStep 2: Rasterize shapefile\nWe will look at lake SpatialPointsDataFrame via plot, then determine the boundary box (bbox) and save it as an object named ext.\n\nplot(lake_spd)\n\n# determine the extent of the SpatialPointsDataFrame\next &lt;- extent(lake_spd)\n\n\nThen we will create the raster, it is important here to control the res argument as that will result in varied resolution. For the vignette I used a resolution of 5 which represents 5 m since we are using UTMs. Using a more fine-scale resolution such as 5 m can be computationally intensive so for large systems scale this value up.\n\ns &lt;- raster(lake_spd, res = 5)\n# remove and change NA values to fit within the extent\ns &lt;- rasterize(x = lake_spd, y = s, field = 1)\n\n# plot raster to make sure it looks appropriate\nplot(s)\n\n\nThe last step is to create the transition layer. Directions will be queens move of 16 spaces. If in a larger systems direction could be reduced from queens space to rook or king, 4 or 8 to reduce computational complexity and speed.\n\ntrans &lt;- transition(x = s, transitionFunction = mean, directions = 16)\n\n\n\nStep 3: Create every combination of paths for every receiver\nFirst we will convert receiver location which is a sf object to a tibble with each location combination.\n\nprep_path &lt;- rl_sum_sf %&gt;%\n  mutate(\n    lon = st_coordinates(.)[,\"X\"],# grab lon\n    lat = st_coordinates(.)[,\"Y\"],# grab lat\n  ) %&gt;%  \n  st_drop_geometry() %&gt;% # drop sf \n  # once geometry removed create to and from lat longs \n  mutate(llon = lon,\n         llat = lat,\n         lonlat = paste0(lon, \",\", lat),\n         llonllat = paste0(llon, \",\", llat)) %&gt;%\n  dplyr::select(-lon, -lat, -llon, -llat) %&gt;%\n  expand(lonlat, llonllat) %&gt;% # expand for each to and from combo \n  separate(lonlat, c(\"lon\", \"lat\"), \",\") %&gt;%\n  separate(llonllat, c(\"llon\", \"llat\"), \",\") %&gt;%\n  mutate_if(is.character, function(x) as.numeric(x)) \n\nprep_path has all of the path combinations but we lose the names of the receivers and which paths go from one receiver to another. We are going to add that information back in by creating an object called rec_order\n\nrec_order &lt;- prep_path %&gt;%\n  left_join( \n    rl_sum_sf %&gt;% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"], # grab lon \n        lat = st_coordinates(.)[,\"Y\"]  # grab lat \n      ) %&gt;% \n      st_drop_geometry() %&gt;% # remove sf \n      rename(from = rec_name) %&gt;%  # Line up from names \n      dplyr::select(from, lon, lat), by = c(\"lon\", \"lat\"), \n    multiple = \"all\"\n  ) %&gt;%  \n  left_join(\n    rl_sum_sf %&gt;% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"]\n      ) %&gt;% \n      st_drop_geometry() %&gt;% \n      rename(to = rec_name,\n             llon = lon) %&gt;% # join for the tos  \n      dplyr::select(to, llon), by = c(\"llon\"), \n    multiple = \"all\"\n  ) %&gt;% \n  mutate(\n    from_to = paste0(from, \"-\", to), \n    id = 1:nrow(.)\n  ) %&gt;% \n  dplyr::select(id, from, to, from_to, lon, lat, llon, llat)\n\nAwesome! We have all of our combinations with their names and we now know which paths go from one receiver to another. The only issue is all of points are in decimal degrees with a CRS of WGS 84, we need to convert this into to UTMs.\nBe sure to choose the correct UTM zone here. This vignette uses UTM zone 15 north but for other uses you will have to change the UTM zone.\n\nrec_order_utm &lt;- st_as_sf(rec_order, \n                          coords = c(\"lon\", \"lat\"), \n                          crs = st_crs(rl_sum_sf)) %&gt;% \n  st_transform(crs = 32615) %&gt;% \n  mutate(\n    lon = st_coordinates(.)[,\"X\"], # grab lon \n    lat = st_coordinates(.)[,\"Y\"]  # grab lat \n  ) %&gt;% \n  st_drop_geometry() %&gt;% \n  st_as_sf(., coords = c(\"llon\", \"llat\"), \n           crs = st_crs(rl_sum_sf)) %&gt;% \n  st_transform(crs = 32615) %&gt;% \n  mutate(\n    llon = st_coordinates(.)[,\"X\"], # grab lon \n    llat = st_coordinates(.)[,\"Y\"]  # grab lat \n  ) %&gt;% \n  st_drop_geometry()\n\n\n\nStep 4: Make shortest paths\nWe will first split our combinations into individual end points, then use purrr::map() to iterate over each combination and use the shortestPath() function to calculate the shortest path for every combination.\nWe then will transform the output of this which are SpatialLinesDataFrame to sf objects. Important note here is to change the CRS to your specific CRS UTM zone.\n\nrec_dist_sf &lt;- rec_order_utm %&gt;%\n  split(.$id) %&gt;%\n  map(possibly(~ shortestPath(trans,\n                              c(.$llon, .$llat),\n                              c(.$lon, .$lat),\n                              output = \"SpatialLines\"), NA)) %&gt;%\n  map(possibly(~ st_as_sf(., crs = 32615), NA)) %&gt;% # u will need to replace CRS\n  bind_rows(.id = \"id\") %&gt;%\n  mutate(\n    cost_dist = as.numeric(st_length(.))\n  )\n\n\n\nStep 5: Add in metadata of paths start and end desitantions\nFirst we will change the id column to a character to be able to line up the data properly.\n\nrec_order_names &lt;- rec_order_utm %&gt;% \n  mutate(\n    id = as.character(id)\n  )\n\nNext we will use left_join() from {dplyr} to connect each path’s metadata.\n\nrec_dist_sf &lt;- rec_dist_sf %&gt;% \n  left_join(rec_order_names, by = \"id\") %&gt;% \n  dplyr::select(id, from:llon, cost_dist, geometry)\n\n\n\nStep 6: Plot\nWe will use ggplot to look at our paths. Lets first check if paths go to the right locations and then we will plot the whole thing.\n\nggplot() +\n  geom_sf(data = lake_utm) +\n  geom_sf(data = rec_dist_sf %&gt;% \n            filter(from_to %in% \"3-12\")\n          , aes(colour = cost_dist), size = 1) +\n  geom_sf_label(data = rl_sum_utm , size = 4, aes(label = rec_name)) +\n  scale_colour_viridis_c(name = \"Cost Distance (m)\", option = \"B\") +\n  theme_void()\n\n\n\nggplot() +\n  geom_sf(data = lake_utm) +\n  geom_sf(data = rec_dist_sf, aes(colour = cost_dist), size = 1) +\n  geom_sf(data = rl_sum_utm , size = 4) +\n  scale_colour_viridis_c(name = \"Cost Distance (m)\", option = \"B\") +\n  theme_void()\n\n From here the sf object can be kept together or ripped apart to determine the distance or path a fish could swim within the system along with a whole host of other potential implications (e.g. interpolated paths).\nCredit: R. Lennox, PhD, Incoming Science Director - OTN for the original ideas around this script."
  }
]