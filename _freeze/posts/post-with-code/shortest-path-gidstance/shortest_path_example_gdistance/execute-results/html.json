{
  "hash": "1557b02ec03025c5569bca8a88e47d84",
  "result": {
    "markdown": "---\ntitle: \"Shortest Paths Within a Boundary - {gdistance}\"\nauthor: \"Benjamin Hlina\"\ndate: \"2023-05-26\"\ncategories: [Spatial Analysis, Telemetry, Movement]\nimage: \"4_big_sissabagama_lake_cost_dist.png\"\nexecute:\n  eval: FALSE\n---\n\n\n### Our Objectives\n\nThe purpose of this vignette is to create the shortest distance among acoustic telemetry receivers within a confined boundary such as a lake, river, delta, or oceanscape. This workflow can be adapted to find the distance between any two points within a confined boundary.\n\nYou can download and unzip this vignette using the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/benjaminhlina/shortest_path_example/archive/refs/heads/master.zip\")\n```\n:::\n\n### Disclaimer \n\nThis vignette uses {gdistance}, {raster}, and {sp} which as of October 2023 were retired. Please use the vignette using [{pathroutr}](https://blog.benjaminhlina.com/posts/post-with-code/shortest-path-pathroutr/shortest_path_example_pathroutr.html) for the timing being until I can update this vignette with using {terra}.  \n\n### Load shapefile and receiver locations\n\nWe will first load all the packages we need, we will use [{gdistance}](https://agrdatasci.github.io/gdistance/) to find the shortest paths, [{sf}](https://r-spatial.github.io/sf/) to find the distances of those shortest paths.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- load packages ----\n{\n  library(dplyr)\n  library(gdistance)\n  library(ggplot2)\n  library(here)\n  library(purrr)\n  library(raster)\n  library(readr)\n  library(sf)\n  library(sp)\n  library(tibble)\n  library(tidyr)\n  make_line <- function(lon, lat, llon, llat) {\n    st_linestring(matrix(c(lon, llon, lat, llat), 2, 2))\n  }\n}\n```\n:::\n\n\nWe will bring bring in our shapefile. This vignette will use Big Sissabagama Lake as it is the lake I grew up fishing on in Wisconsin, USA. Please replace with the shapefile of your desired body of water.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake <- st_read(dsn = here(\"Data\",\n                           \"shapefile\",\n                           \".\"),\n                layer = \"sissabagama_lake\")\n```\n:::\n\n\nImportant that you convert to the correct UTM zone. For the vignette we are using UTM zone 15 N. Adjust your UTM zone accordingly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_utm <- st_transform(lake, crs = 32615)\n```\n:::\n\n\nCreate `SpatialPloygonDataFrame` we will use it to create a raster that will be a transition layer for paths to move across. We will use `lake_utm` as we need our raster layer in UTMs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_spd <- as_Spatial(lake_utm)\n```\n:::\n\n\nWe will then bring in our receiver locations. Replace `rl_sum_sf` with your receiver locations as a RDS or csv file type or whatever you use to document receiver locations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrl_sum_sf <- read_rds(here(\"Data\",\n                           \"receiver locations\",\n                           \"rl_sum_sf.rds\"))\n```\n:::\n\n\nConvert to UTMs for plotting purposes and make sure you use the correct UTM zone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrl_sum_utm <- st_transform(rl_sum_sf, crs = 32615)\n```\n:::\n\n\n### Rasterize shapefile\n\nWe will  look at lake `SpatialPointsDataFrame` via plot, then determine the boundary box (bbox) and save it as an object named `ext`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(lake_spd)\n\n# determine the extent of the SpatialPointsDataFrame\next <- extent(lake_spd)\n```\n:::\n\n\n![](1_big_sissabagama_lake_spd.png)\n\nThen we will create the raster, it is important here to control the `res` argument as that will result in varied resolution. For the vignette I used a resolution of 5 which represents 5 m since we are using UTMs. Using a more fine-scale resolution such as 5 m can be computationally intensive so for large systems scale this value up.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- raster(lake_spd, res = 5)\n# remove and change NA values to fit within the extent\ns <- rasterize(x = lake_spd, y = s, field = 1)\n\n# plot raster to make sure it looks appropriate\nplot(s)\n```\n:::\n\n\n![](2_big_sissabagama_lake_raster.png)\n\nThe last step is to create the transition layer. Directions will be queens move of 16 spaces. If in a larger systems direction could be reduced from queens space to rook or king, 4 or 8 to reduce computational complexity and speed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans <- transition(x = s, transitionFunction = mean, directions = 16)\n```\n:::\n\n\n### Create every combination of paths for every receiver\n\nFirst we will convert receiver location which is a `sf object` to a `tibble` with each location combination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprep_path <- rl_sum_sf %>%\n  mutate(\n    lon = st_coordinates(.)[,\"X\"],# grab lon\n    lat = st_coordinates(.)[,\"Y\"],# grab lat\n  ) %>%  \n  st_drop_geometry() %>% # drop sf \n  # once geometry removed create to and from lat longs \n  mutate(llon = lon,\n         llat = lat,\n         lonlat = paste0(lon, \",\", lat),\n         llonllat = paste0(llon, \",\", llat)) %>%\n  dplyr::select(-lon, -lat, -llon, -llat) %>%\n  expand(lonlat, llonllat) %>% # expand for each to and from combo \n  separate(lonlat, c(\"lon\", \"lat\"), \",\") %>%\n  separate(llonllat, c(\"llon\", \"llat\"), \",\")\n```\n:::\n\n\n`prep_path` has all of the path combinations but we lose the names of the receivers and which paths go from one receiver to another. We are going to add that information back in by creating an object called `rec_order`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_order <- prep_path %>%\n  left_join( \n    rl_sum_sf %>% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"], # grab lon \n        lat = st_coordinates(.)[,\"Y\"]  # grab lat \n      ) %>% \n      st_drop_geometry() %>% # remove sf \n      rename(from = rec_name) %>%  # Line up from names \n      dplyr::select(from, lon, lat) %>% \n      mutate(across(.cols = c(lon, lat), as.character)) , by = c(\"lon\", \"lat\"), \n    multiple = \"all\"\n  ) %>%  \n  left_join(\n    rl_sum_sf %>% \n      mutate(\n        lon = st_coordinates(.)[,\"X\"]\n      ) %>% \n      st_drop_geometry() %>% \n      rename(to = rec_name,\n             llon = lon) %>% # join for the tos  \n      dplyr::select(to, llon) %>% \n      mutate(llon = as.character(llon)), by = c(\"llon\"), \n    multiple = \"all\"\n  ) %>% \n  mutate(\n    from_to = paste0(from, \"-\", to), \n    id = 1:nrow(.)\n  ) %>% \n  dplyr::select(id, from, to, from_to, lon, lat, llon, llat) %>% \n  mutate(across(.col = c(lon, lat, llon, llat), as.numeric))\n```\n:::\n\n\nAwesome! We have all of our combinations with their names and we now know which paths go from one receiver to another. The only issue is all of points are in decimal degrees with a CRS of WGS 84, we need to convert this into to UTMs.\n\nBe sure to choose the correct UTM zone here. This vignette uses UTM zone 15 north but for other uses you will have to change the UTM zone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_order_utm <- st_as_sf(rec_order, \n                          coords = c(\"lon\", \"lat\"), \n                          crs = st_crs(rl_sum_sf)) %>% \n  st_transform(crs = 32615) %>% \n  mutate(\n    lon = st_coordinates(.)[,\"X\"], # grab lon \n    lat = st_coordinates(.)[,\"Y\"]  # grab lat \n  ) %>% \n  st_drop_geometry() %>% \n  st_as_sf(., coords = c(\"llon\", \"llat\"), \n           crs = st_crs(rl_sum_sf)) %>% \n  st_transform(crs = 32615) %>% \n  mutate(\n    llon = st_coordinates(.)[,\"X\"], # grab lon \n    llat = st_coordinates(.)[,\"Y\"]  # grab lat \n  ) %>% \n  st_drop_geometry()\n```\n:::\n\n\n### Make shortest paths\n\nWe will first split our combinations into individual end points, then use `purrr::map()` to iterate over each combination and use the `shortestPath()` function to calculate the shortest path for every combination.\n\nWe then will transform the output of this which are `SpatialLinesDataFrame` to `sf objects`. Important note here is to change the CRS to your specific CRS UTM zone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_dist_sf <- rec_order_utm %>%\n  split(.$id) %>%\n  map(possibly(~ shortestPath(trans,\n                              c(.$llon, .$llat),\n                              c(.$lon, .$lat),\n                              output = \"SpatialLines\"), NA)) %>%\n  map(possibly(~ st_as_sf(., crs = 32615), NA)) %>% # u will need to replace CRS\n  bind_rows(.id = \"id\") %>%\n  mutate(\n    cost_dist = as.numeric(st_length(.))\n  )\n```\n:::\n\n\n### Add in metadata of paths start and end desitantions\n\nFirst we will change the `id` column to a `character` to be able to line up the data properly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_order_names <- rec_order_utm %>% \n  mutate(\n    id = as.character(id)\n  )\n```\n:::\n\n\nNext we will use `left_join()` from `{dplyr}` to connect each path's metadata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_dist_sf <- rec_dist_sf %>% \n  left_join(rec_order_names, by = \"id\") %>% \n  dplyr::select(id, from:llon, cost_dist, geometry)\n```\n:::\n\n\n### Plot\n\nWe will use `ggplot` to look at our paths. Lets first check if paths go to the right locations and then we will plot the whole thing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = lake_utm) +\n  geom_sf(data = rec_dist_sf %>% \n            filter(from_to %in% \"3-12\")\n          , aes(colour = cost_dist), size = 1) +\n  geom_sf_label(data = rl_sum_utm , size = 4, aes(label = rec_name)) +\n  scale_colour_viridis_c(name = \"Cost Distance (m)\", option = \"B\") +\n  theme_void()\n```\n:::\n\n\n![](3_big_sissabagama_lake_cost_dist_one.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = lake_utm) +\n  geom_sf(data = rec_dist_sf, aes(colour = cost_dist), size = 1) +\n  geom_sf(data = rl_sum_utm , size = 4) +\n  scale_colour_viridis_c(name = \"Cost Distance (m)\", option = \"B\") +\n  theme_void()\n```\n:::\n\n\n![](4_big_sissabagama_lake_cost_dist.png)\nFrom here the `sf` object can be kept together or ripped apart to determine the distance or path a fish could swim within the system along with a whole host of other potential implications (e.g. interpolated paths).\n\nCredit: [R. Lennox, PhD, Incoming Science Director - OTN](https://oceantrackingnetwork.org/staff/) for the original ideas around this script.\n",
    "supporting": [
      "shortest_path_example_gdistance_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}