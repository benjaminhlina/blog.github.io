{
  "hash": "c6730d5a40aaa098709a9a4dcf617621",
  "result": {
    "markdown": "---\ntitle: \"Animal movement across a boundary\"\nauthor: \"Benjamin L. Hlina\"\ndate: \"2023-12-06\"\nimage: \"01_movement_outside_bnd.png\"\ncategories: [Spatial Analysis, Acoustic Telemetry, Movement]\neditor_options: \n  chunk_output_type: inline\n---\n\n\n### Our Objectives\n\nThe purpose of the is vignette is to determine when (i.e., time stamps), where (i.e., nodes) and how long, an animal takes to cross a boundary (i.e., line or polygon). The rational for wanting to determine time spent crossing a boundary could be multiple situations. For example, wanting to estimate the amount of time it took for a fish to migrate into or out of a marine protected area (MPA) or a commercial fishing zone in Lake Michigan using satellite or acoustic telemetry data. This vignette was inspired the following [twitter post](https://twitter.com/spoonbill_hank/status/1731742735453880428) with the initial ideas of a solution inspired by the following [blog post](https://www.jessesadler.com/post/network-analysis-with-r/) focused on network analysis by [Jesse Sadler](https://www.jessesadler.com/). Additional chunks of code came from [Shortest Paths Within a Boundary - {pathroutr}](https://blog.benjaminhlina.com/posts/post-with-code/shortest-path-pathroutr/shortest_path_example_pathroutr.html) and within functions in [{soapcheckr}](https://github.com/dill/soapcheckr). Another interesting note is that this problem might be solved with functions from [{lwgeom}](https://r-spatial.github.io/lwgeom/) and [{sftime}](https://r-spatial.github.io/sftime/). I don't have much experience using either of those packages but they might provide an easier workflow to answer this problem. \n\n\nYou can download and unzip this vignette using the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/benjaminhlina/find-ts-bnd/archive/refs/heads/master.zip\")\n```\n:::\n\n\n\n### load packages, data, and boundary \n\nWe will first load all the packages we need, we will use [{lwgeom}](https://r-spatial.github.io/lwgeom/) to extract `lat` and `lon` of each change in direction using `st_startpoint()` and `st_endpoint()` and [{sf}](https://r-spatial.github.io/sf/) to find tracks that cross our boundary. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  library(dplyr)\n  library(ggplot2)\n  library(here)\n  library(lwgeom)\n  library(purrr)\n  library(readr)\n  library(sf)\n  make_line <- function(lon, lat, llon, llat) {\n    st_linestring(matrix(c(lon, llon, lat, llat), 2, 2,))\n  }\n}\n```\n:::\n\n\nNext we will bring in our example detection data for a single fish that was tagged with a satellite or acoustic telemetry transmitter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read_csv(here(\"data\", \n                     \"example_movement_data.csv\"))\nglimpse(dat)\n```\n:::\n\n\nFor initial plotting purposes we will transform our detection data into a `sf` object that is a compilation of all the movements into a `LINESTRING`. We will only use `dat_sf` for plotting not manipulation to answer this problem. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_sf <- dat %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %>% \n  group_by(id) %>% \n  summarise(do_union = FALSE) %>% \n  st_cast(\"LINESTRING\")\n```\n:::\n\n\nNext we will bring in our example MPA shapefile as a `sf` object. For this exercise the boundary needs to be either a `LINESTRING` or `MULTILINESTRING` as `POLYGON` and `MULTIPOLYGON` will not work because the area inside the polygon is considered filled. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbnd <- st_read(dsn = here(\"data\", \n                          \"shapefile\", \n                          \".\"), \n               layer = \"example_mpa\") %>% \n  st_cast(\"MULTILINESTRING\")\n```\n:::\n\n\n### Intial plot of movement \n\nWe will use [{ggplot2}](https://ggplot2.tidyverse.org/reference/ggplot.html) and `geom_sf()` to initially visualize our tracks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = bnd, fill = NA, colour = \"blue\", linewidth = 1) + \n  geom_sf(data = dat_sf) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWe can notice that there are few times the fish moves from outside to inside of the MPA or vis versa. We want to know the location of those two nodes and the time between the detections to know how long it took the fish to move from outside to inside and vis versa.\n\n### Create our from and to data frame     \n\nWe need to take the detection data and split it up so that each subsequent detection timestamp, latitude, and longitude are in a separate column. We can do this by using the `lag()` function from either [{dplyr}](https://dplyr.tidyverse.org/) or [{data.table}](https://rdatatable.gitlab.io/data.table/). We will also set the argument `default` for `dplyr::lag()` to equal `first(YOUR_VARIABLE_NAME)` so when lagging back to the previous value for the first time, `lag()` does not create a `NA` value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_from <- dat %>% \n  mutate(\n    from_ts = dplyr::lag(time_stamp, default = first(time_stamp)),\n    to_ts = time_stamp,\n    llat = dplyr::lag(lat, default = first(lat)),\n    llon = dplyr::lag(lon, default = first(lon)),\n  ) %>% \n  dplyr::select(-time_stamp)\n```\n:::\n\n\n### Create our tracks for each change in direction \n\nNow that we have our to and from dataframe we are going to select the from and to latitudes and longitudes and make each movement a `LINESTRING` using the supplied function above `make_line()`. We will then convert that into a complied `sf` object and extract the longitudes from each movement `LINESTRING` using `st_startpoint()` and `st_endpoint()` from [{lwgeom}](https://r-spatial.github.io/lwgeom/). We will add this as a column to our `sf` object and transform it to a `character` because the next step involves `left_join()` from [{dplyr}](https://dplyr.tidyverse.org/) which cannot join based on a double precision numeric. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracks_sf <- to_from %>%\n  dplyr::select(lon, lat, llon,llat) %>% \n  pmap(make_line) %>%\n  st_as_sfc(crs = 4326) %>%\n  st_sf() %>% \n  mutate(\n    lon = st_startpoint(.) %>%\n      st_coordinates(.) %>%\n      as_tibble() %>%\n      .$X %>% \n      as.character(),\n    llon = st_endpoint(.) %>%\n      st_coordinates(.) %>%\n      as_tibble() %>%\n      .$X %>% \n      as.character()\n  )\n```\n:::\n\n\n### Join our tracks to our from and to timestamps \n\nFirst we need to make sure our from and to latitudes and longitudes are characters otherwise `left_join()` will not work. We will also select the columns we only need to join. If you want to know the location of each node you can select all from and to latitudes and longitudes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_from_select <- to_from %>% \n  mutate(across(.cols = c(lon, lat, llon, llat), as.character)) %>% \n  dplyr::select(id, lon, llon, from_ts, to_ts)\n```\n:::\n\n\nNext we will `left_join()` our tracks `sf` object to our timestamps and fish id dataframe\nlastly we will drop the `lon` and `llon` columns as we no longer need them in our `sf` object unless you want the location of each from and to node. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracks_sf <- tracks_sf %>% \n  left_join(to_from_select,\n            by = c(\"lon\", \"llon\")) %>% \n  dplyr::select(-c(\"lon\", \"llon\"))\n```\n:::\n\n\n### Determine the movments that fall outside the boundary \n\nWe can use `st_intersects()` with the `sparse` argument set to `FALSE`. This will produce a matrix of `TRUE` or `FALSE` depending on whether each `LINESTRING` intersects the boundary. To return a vector of `TRUE/FALSE` instead of a matrix we add the `[TRUE]` at the end of the call of `st_intersects()`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracks_sf <- tracks_sf %>% \n  mutate(\n    x_bnd = st_intersects(bnd, tracks_sf, sparse = FALSE)[TRUE]\n  )\n```\n:::\n\n\nCongratulations! We now have a column of `TRUE/FALSE` that lets us know whether or not the fish crossed the boundary. We can then filter out any movement that didn't cross the boundary. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracks_sf_x <- tracks_sf %>% \n  filter(x_bnd %in% TRUE)\n```\n:::\n\n\n### Plotting tracks that cross the boundary \n\nWe can use [{ggplot}](https://ggplot2.tidyverse.org/reference/ggplot.html) or [{mapview}](https://r-spatial.github.io/mapview/) to view when the fish moved across the boundary. [{mapview}](https://r-spatial.github.io/mapview/) is nice to create an interactive plot for exploration but for any type of publication or report you'll more than likely need a static figure and can produce it using [{ggplot}](https://ggplot2.tidyverse.org/reference/ggplot.html). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = bnd, colour = \"blue\", size = 1, fill = NA) + \n  geom_sf(data = tracks_sf_x) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### Calculate time it took to cross the boundary \n  \nWe can use the base function `difftime()` to get the time difference between our from and to detections. By calculating the time difference we now know the duration it took the fish to migrate across the boundary. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracks_sf_x <- tracks_sf %>% \n  mutate(\n    time_diff = difftime(to_ts, from_ts)\n  )\n```\n:::\n\n\nYou will notice that the difference in time in this example is consistent becasue the example dataset uses a manufactured sequence that is equally spaced. In your dataset this column should vary depending on how the fish moved. \n\nCongratulations! You have now determined when, where, and how long it took for a fish to migrate across a boundary! ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}