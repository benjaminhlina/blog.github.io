{
  "hash": "239d74550642e68b91794b7c96db6233",
  "result": {
    "markdown": "---\ntitle: \"Estimating Trophic Niches - {nicheROVER} and {ggplot2}\"\nauthor: \"Benjamin Hlina\"\ndate: \"2023-07-05\"\nimage: \"1_ellispes_density_biplot.png\"\ncategories: [Stable Isotopes, Trophic Dynamics, Food Webs]\neditor_options: \n  chunk_output_type: inline\n---\n\n\n### Our Objectives:\n\nThe purpose of this vignette is to use [{ggplot2}](https://ggplot2.tidyverse.org/) to visualize  estimates of trophic niche size and overlap of multiple freshwater fish. \n\nThis vignette can be used for additional purposes including estimating niche size and overlap among different groups of aquatic and/or terrestrial species. Furthermore, niche size and overlap of different behaviour types of the same species indicated through acoustic telemetry can be estimated (e.g., differences in habitat occupancy).\n\n### Step 1: Bring in trophic niche data\nFirst we will load the necessary packages to preform the analysis and visualization. We will use [{nicheROVER}](https://cran.r-project.org/web/packages/nicheROVER/index.html) and [{ellipse}](https://cran.r-project.org/web/packages/ellipse/index.html) to preform the analysis. We will use [{dplyr}](https://dplyr.tidyverse.org/), [{purrr}](https://purrr.tidyverse.org/), and [{tidyr}](https://tidyr.tidyverse.org/) to manipulate data and iterate processes. Lastly, we will use [{ggplot2}](https://ggplot2.tidyverse.org/), [{ggtext}](https://wilkelab.org/ggtext/), and [{patchwork}](https://patchwork.data-imaginist.com/) to plot, add labels and arrange plots.\n\nI will add that many of the `{dplyr}` and `{tidyr}` functions and processes can be replaced using [{data.table}](https://cran.r-project.org/web/packages/data.table/index.html) which is great when working with large datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  library(dplyr)\n  library(ellipse)\n  library(ggplot2)\n  library(ggtext)\n  library(here)\n  library(nicheROVER) \n  library(purrr)\n  library(patchwork)\n  library(readr)\n  library(stringr)\n  library(tidyr)\n}\n```\n:::\n\n\nFor the purpose of the vignette we will be using the `fish` dataframe that is available within `{nicheROVER}`. We will remove $\\delta$<sup>34</sup>S for simplicity of the vignette. If more than two isotopes or metrics are being used to compare niche size and overlap, you can make modify the code to include the additional isotopes or metrics. \n\nWe will first use the function `janitor::clean_names()` to clean up column names and remove $\\delta$<sup>34</sup>S column. For your purposes you will need to replace fish with your dataframe either by loading a csv or rds with your data. You can do this multiple ways, I prefer using `readr::read_csv()` but base R works perfectly fine.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- fish %>% \n  janitor::clean_names() %>% \n  select(-d34s)\n```\n:::\n\n\nIf there are any isotopic values that did not run and are `NA`, they will need to be removed because `{nicheROVER}`'s functions will not accommodate values of `NA`.\n\n### Step 2: Estimate posterior distribution with Normal-Inverse-Wishart (NIW) priors.\n\nWe will take 1,000 posterior samples for each group. You can change this but suggest nothing less than 1,000. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsample <- 1000\n```\n:::\n\n\nWe wlll then split the dataframe into a list with each species as a dataframe object within the list, We will then iterate over the list, using `map()` from [{purrr}](https://purrr.tidyverse.org/), to estimate posterior distribution using Normal-Inverse-Wishart (NIW) priors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfish_par <- df %>% \n  split(.$species) %>% \n  map(~ select(., d15n, d13c)) %>% \n  map(~niw.post(nsample = nsample, X = .))\n```\n:::\n\n\n### Step 3: Extract $\\mu$ values from list object containing posteriors \n\nWe will use a combination of `map()` and `pluck()` to first extract the list of posteriors for $\\mu$. We will extract each vector object for $\\mu$ of each species using `imap()` and convert them into a `tibble`.\n\nWe then will merge each $\\mu$ dataframe together for each species using `bind_rows()`. We will add `species` and `sample_number` back into the dataframe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_mu <- map(fish_par, pluck, 1) %>% \n  imap(~ as_tibble(.x) %>% \n         mutate( \n           metric = \"mu\", \n           species = .y\n         )\n  ) %>%\n  bind_rows() %>% \n  mutate(\n    species = factor(species, \n                     levels = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\"))\n  ) %>% \n  group_by(species) %>% \n  mutate(\n    sample_number = 1:1000\n  ) %>% \n  ungroup()\n```\n:::\n\nWe need to manipulate `df_mu` into long instead of wide format for the rest of the analysis. We will also add in a column that is the element abbreviation and neutron number to be used in axis labeling. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_mu_long <- df_mu %>% \n  pivot_longer(cols = -c(metric, species, sample_number), \n               names_to = \"isotope\", \n               values_to = \"mu_est\") %>% \n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    ) \n  )\n```\n:::\n\n\n### Step 4: Extract $\\Sigma$ values from list object containing posteriors \nWe will use a combination of `map()` and `pluck()` to first extract the list of posteriors for $\\Sigma$. We will extract each vector object from each the $\\Sigma$ of each species using `imap()` and convert them into a `tibble`.\n\nWe will manipulate `df_sigma` from wide to long format. When doing so we create two columns, `id` and `isotope`, that identify the two isotopes that $\\Sigma$ is being estimated for. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma <- map(fish_par, pluck, 2) %>%\n  imap(~ as_tibble(.x) %>%\n         mutate(\n           metric = \"sigma\",\n           id = c(\"d15n\", \"d13c\"),\n           species = .y\n         )\n  ) %>%\n  bind_rows() %>%\n  pivot_longer(cols = -c(\"id\", \"species\", \"metric\"),\n               names_to = \"isotope\",\n               values_to = \"post_sample\"\n  )  %>%\n  separate(isotope, into = c(\"isotopes\", \"sample_number\"), sep = \"\\\\.\")\n```\n:::\n\n\nWe then need to remove $\\Sigma$ values for when the two columns are the same isotope. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma_cn <- df_sigma %>%\n  filter(id != isotopes)\n```\n:::\n\n\n\n### Step 5: Plot posterior distrubtion of $\\mu$ and $\\Sigma$ using [{ggplot2}](https://ggplot2.tidyverse.org/)\n\nFor most plotting within this vignette, I will `split()` the dataframe by isotope, creating a list that I will then use `imap()` to iterate over the list to create plots. We will use `geom_density()` to represent densities for both $\\mu$ and $\\Sigma$. Plot objects will then be stored in a list. \n\nFirst we will plot $\\mu$ for each isotope. We will use [{patchwork}](https://patchwork.data-imaginist.com/) to configure plots for multi-panel figures. The package is phenomenal and uses math operators to configure and manipulate the plots to create multi-panel figures.\n\nFor labeling we are also going to use `element_markdown()` from [{ggtext}](https://wilkelab.org/ggtext/) to work with the labels that are needed to correctly display the isotopic signature. If you are working other data please replace. \n\n\n::: {.cell fig.format='svg'}\n\n```{.r .cell-code}\nposterior_plots <- df_mu_long %>%\n  split(.$isotope) %>%\n  imap(\n    ~ ggplot(data = ., aes(x = mu_est)) +\n      geom_density(aes(fill = species), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\"\n      ) +\n      labs(\n        x = paste(\"\\u00b5<sub>\\U03B4</sub>\", \"<sub><sup>\",\n                  unique(.$neutron), \"</sup></sub>\",\n                  \"<sub>\",unique(.$element), \"</sub>\", sep = \"\"),\n        y = paste0(\"p(\\u00b5 <sub>\\U03B4</sub>\",\"<sub><sup>\",\n                   unique(.$neutron), \"</sub></sup>\",\n                   \"<sub>\",unique(.$element),\"</sub>\",\n                   \" | X)\"), sep = \"\")\n  )\n\nposterior_plots$d15n +\n  theme(legend.position = c(0.18, 0.84)) + \n  posterior_plots$d13c\n```\n\n::: {.cell-output-display}\n![](nicheROVER_ggplot_files/figure-html/unnamed-chunk-9-1.png){width=100%}\n:::\n:::\n\nFor labeling purposes we need to add columns that are the element abbreviation and neutron number. I do this by using `case_when()` which are vectorized if else statements. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma_cn <- df_sigma_cn %>%\n  mutate(\n    element_id = case_when(\n      id == \"d15n\" ~ \"N\",\n      id == \"d13c\" ~ \"C\",\n    ),\n    neutron_id = case_when(\n      id == \"d15n\" ~ 15,\n      id == \"d13c\" ~ 13,\n    ),\n    element_iso = case_when(\n      isotopes == \"d15n\" ~ \"N\",\n      isotopes == \"d13c\" ~ \"C\",\n    ),\n    neutron_iso = case_when(\n      isotopes == \"d15n\" ~ 15,\n      isotopes == \"d13c\" ~ 13,\n    )\n  )\n```\n:::\n\n\nNext we will plot the posteriors for $\\Sigma$.\n\n::: {.cell fig.format='svg'}\n\n```{.r .cell-code}\nsigma_plots <- df_sigma_cn %>%\n  group_split(id, isotopes) %>%\n  imap(\n    ~ ggplot(data = ., aes(x = post_sample)) +\n      geom_density(aes(fill = species), alpha = 0.5) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw() +\n      theme(panel.grid = element_blank(),\n            axis.title.x =  element_markdown(),\n            axis.title.y =  element_markdown(),\n            legend.position = \"none\"\n      ) +\n      labs(\n        x = paste(\"\\U03A3\",\"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_id), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_id),\"</sub>\",\" \",\n                  \"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_iso), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_iso),\"</sub>\", sep = \"\"),\n        y = paste(\"p(\", \"\\U03A3\",\"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_id), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_id),\"</sub>\",\" \",\n                  \"<sub>\\U03B4</sub>\",\n                  \"<sub><sup>\", unique(.$neutron_iso), \"</sub></sup>\",\n                  \"<sub>\",unique(.$element_iso),\"</sub>\", \" | X)\", sep = \"\"),\n      )\n  )\n\nsigma_plots[[1]] + \n  theme(legend.position = c(0.1, 0.82))\n```\n\n::: {.cell-output-display}\n![](nicheROVER_ggplot_files/figure-html/unnamed-chunk-11-1.png){width=100%}\n:::\n:::\n\n### Step 6: Estimate niche ellipse \n\nWe  need to manipulate `df_sigma` back to wide format for ellipses. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sigma_wide <- df_sigma %>%\n  pivot_wider(names_from = id,\n              values_from = post_sample)\n```\n:::\n\n\n\nNext we will use a for loop to estimate niche ellipses for all 1,000 samples. The default confidence level is 0.95 but can be adjusted by changing `p.ell`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\np.ell <- 0.95\n```\n:::\n\n\nWe will then create a vector of unique species (i.e., groups), that we loop over. \n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_name <- unique(df_sigma_wide$species)\n```\n:::\n\n\nNext create an empty list to dump the results of the for loop. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_ellipses <- list()\n```\n:::\n\n\nWe then will use the following `for` loop. First it subsets `mu` and `sigma` objects by species. Then it extracts $\\mu$ and $\\Sigma$ values for each sample number for each isotope and each species. Then $\\mu$ and $\\Sigma$ are given to `ellipse()` from [{ellipse}](https://cran.r-project.org/web/packages/ellipse/index.html) that will generate a unique ellipse with a confidence interval of `p.ell` for each sample (e.g., 1,000 samples). We need to add in dummy variables (`ell` and `post.id`) in the first loop that we will add to within the second loop. \n\nIf you are to have additional isotopes or metrics, you will need to modify this loop to include them. Specifically `ellipse()` can only work within two-dimensions, not three so you will have to create multiple `ellipse()` calls for each combination of isotopes or metrics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(species_name)) {\n  \n  sigma_species <- df_sigma_wide %>% \n    filter(species %in% species_name[i])\n  \n  mu_species <- df_mu %>% \n    filter(species %in% species_name[i])\n  \n  ell <- NULL\n  post.id <- NULL\n  \n  for(j in 1:length(unique(sigma_species$sample_number))) {\n    \n    sigma_ind <- sigma_species %>%\n      filter(sample_number %in% sample_number[j]) %>% \n      dplyr::select(d15n, d13c) \n    \n    Sigma <- as.matrix(sigma_ind, 2, 2)\n    row.names(Sigma) <- c(\"d15n\", \"d13c\")\n    \n    mu <- mu_species %>%\n      filter(sample_number %in% sample_number[j]) %>% \n      dplyr::select(sample_number, d15n, d13c) %>% \n      pivot_longer(cols = -sample_number, \n                   names_to = \"isotope\", \n                   values_to = \"mu\") %>% \n      .$mu\n    \n    out <- ellipse::ellipse(Sigma, centre = mu, which = c(1, 2), level = p.ell)\n    \n    ell <- rbind(ell, out)\n    post.id <- c(post.id, rep(j, nrow(out)))\n  }\n  ell <- as.data.frame(ell)\n  ell$rep <- post.id\n  all_ellipses[[i]] <- ell\n}\n```\n:::\n\n\nWe then will then take the resulting list and merge together to create a dataframe that can be used in plotting. I use the argument `.id` to designate a unique number to each object in the list because each dataframe object in the list is estimated ellipses for each species (e.g., 1-4). we then will use `case_when()` to add in a column with our species identifiers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# combine ellipose list into dataframe and add species names back in \nellipse_df <- bind_rows(all_ellipses, .id = \"id\") %>% \n  mutate(\n    species = factor(\n      case_when(\n        id == \"1\" ~ \"ARCS\",\n        id == \"2\" ~ \"BDWF\",\n        id == \"3\" ~ \"LKWF\",\n        id == \"4\" ~ \"LSCS\",\n      ), level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\")\n    )\n  ) %>% \n  as_tibble()\n```\n:::\n\n\nWe will randomly sample 10 ellipses out of 1000. You can change this but this seems pretty standard. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nellipse_df %>% \n  group_by(species, rep) %>% \n  nest() %>%\n  group_by(species) %>% \n  slice_sample(n = 10, replace = TRUE) %>% \n  ungroup() %>% \n  unnest(cols = c(data)) -> random_ellipse \n```\n:::\n\n### Step 7: Plot ellipses, densities of each istope, and isotope biplot \n\nWe will first plot the ellipse for each species \n\n::: {.cell}\n\n```{.r .cell-code}\nellipse_plots <- ggplot() + \n  geom_polygon(data = random_ellipse,\n               mapping = aes(x = d13c, y = d15n,\n                             group = interaction(rep, species),\n                             color = species),\n               fill = NA,\n               linewidth = 0.5) + \n  \n  scale_colour_viridis_d(begin = 0.25, end = 0.75, \n                         option = \"D\", name = \"species\",\n  ) + \n  scale_x_continuous(breaks = rev(seq(-20, -40, -2))) +\n  scale_y_continuous(breaks = seq(6, 16, 2)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.title.align = 0.5,\n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n```\n:::\n\nWe need to turn `df` into long format to iterate over using `imap()` to easily create density plots. You will notice that I again use `case_when()` to make columns of elment abbrevations and neutron numbers that will be used in plot labelling. \n\n\n::: {.cell}\n\n```{.r .cell-code}\niso_long <- df %>%\n  pivot_longer(cols = -species,\n               names_to = \"isotope\", \n               values_to = \"value\") %>% \n  mutate(\n    element = case_when(\n      isotope == \"d15n\" ~ \"N\",\n      isotope == \"d13c\" ~ \"C\",\n    ), \n    neutron = case_when(\n      isotope == \"d15n\" ~ 15,\n      isotope == \"d13c\" ~ 13,\n    )\n  )\n```\n:::\n\n\nWe will then make density plots for each isotope using `geom_density()`\n\n::: {.cell}\n\n```{.r .cell-code}\niso_density <- iso_long %>% \n  group_split(isotope) %>% \n  imap(\n    ~ ggplot(data = .) + \n      geom_density(aes(x = value, \n                       fill = species), \n                   alpha = 0.35, \n                   linewidth = 0.8) +\n      scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                           option = \"D\", name = \"Species\") +\n      theme_bw(base_size = 10) +\n      theme(axis.text = element_text(colour = \"black\"),\n            panel.grid = element_blank(), \n            legend.position = c(0.15, 0.65), \n            legend.title.align = 0.5,\n            legend.background = element_blank(), \n            axis.title.x = element_markdown(family = \"sans\")) + \n      labs(x =  paste(\"\\U03B4\",\n                      \"<sup>\", unique(.$neutron), \"</sup>\",unique(.$element), \n                      sep = \"\"), \n           y = \"Density\")\n  )\n\nd13c_density <- iso_density[[1]] + \n  scale_x_continuous(breaks = rev(seq(-20, -34, -2)),\n                     limits = rev(c(-20, -34)))\n\nd15n_density <- iso_density[[2]] +\n  scale_x_continuous(breaks = seq(5, 15, 2.5), \n                     limits = c(5, 15)) + \n  theme(\n    legend.position = \"none\"\n  )\n```\n:::\n\nLastly we will use `geom_point()` to make isotopic biplot. \n\n::: {.cell}\n\n```{.r .cell-code}\niso_biplot <- ggplot() + \n  geom_point(data = df, aes(x = d13c, y = d15n,\n                            fill = species),\n             shape = 21, colour = \"black\", \n             stroke = 0.8,\n             size = 3, alpha = 0.70) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"species\") +\n  scale_x_continuous(breaks = rev(seq(-20, -39, -1))) +\n  scale_y_continuous(breaks = seq(5, 17, 1)) +\n  theme_bw(base_size = 10) +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(), \n        legend.position = \"none\", \n        legend.title.align = 0.5,\n        legend.background = element_blank()) + \n  labs(x = expression(paste(delta ^ 13, \"C\")), \n       y = expression(paste(delta ^ 15, \"N\")))\n```\n:::\n\n\n### Step 8: Use {patchwork} to make ellipse, density, and biplots into a paneled figure. \n\n\n\nWe can also use the function `plot_annotation()` to add lettering to the figure that can be used in the figure description. To maneuver where `plot_annotation()` places the lettering, we need to add `plot.tag.position = c(x, y)` to the `theme()` call in every plot. \n\n\n::: {.cell fig.format='svg'}\n\n```{.r .cell-code}\nd13c_density + ellipse_plots + iso_biplot + d15n_density +\n  plot_annotation(tag_levels = \"a\", \n                  tag_suffix = \")\")\n```\n\n::: {.cell-output-display}\n![](nicheROVER_ggplot_files/figure-html/unnamed-chunk-23-1.png){width=100%}\n:::\n:::\n\n\n### Step 9: Determine the 95% niche similarties for each species \n\nWe will use the `overlap()` function from [{nicheROVER}](https://cran.r-project.org/web/packages/nicheROVER/index.html) to estimate the percentage of similarty among species. We will set overlap to assess based on 95% similarities. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nover_stat <- overlap(fish_par, nreps = nsample, nprob = 1000, \n                     alpha = 0.95)\n```\n:::\n\n\nWe then are going transform this output to a data frame and make the data frame long format for plotting so we can assess overall similarities among species. \n\n::: {.cell}\n\n```{.r .cell-code}\nover_stat_df <- over_stat %>% \n  as_tibble(rownames = \"species_a\") %>% \n  mutate(\n    id = 1:nrow(.), \n    species_a = factor(species_a, \n                       level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\"))\n  ) %>% \n  pivot_longer(cols = -c(id, species_a), \n               names_to = \"species_b\", \n               values_to = \"mc_nr\")  %>% \n  separate(species_b, into = c(\"species_c\", \"sample_number\"), \n           sep = \"\\\\.\") %>% \n  select(-id) %>% \n  rename(species_b = species_c) %>% \n  mutate(\n    species_b =  factor(species_b, \n                        level = c(\"ARCS\", \"BDWF\", \"LKWF\", \"LSCS\")\n                        ), \n    mc_nr_perc = mc_nr * 100\n  )\n```\n:::\n\n\nWe then are going to take our newly made data frame and extract out the mean percentage of similarities and the 2.5% and 97.5% quarantines. We plot these as lines and dotted lines on our percent similarty density figure. \n\n::: {.cell}\n\n```{.r .cell-code}\nover_sum <- over_stat_df %>% \n  group_by(species_a, species_b) %>% \n  summarise(\n    mean_mc_nr = round(mean(mc_nr_perc), digits = 2),\n    qual_2.5 = round(quantile(mc_nr_perc, probs = 0.025, na.rm = TRUE), digits = 2), \n    qual_97.5 = round(quantile(mc_nr_perc, probs = 0.975, na.rm = TRUE), digits = 2)\n  ) %>% \n  ungroup() %>% \n  pivot_longer(cols = -c(species_a, species_b, mean_mc_nr), \n               names_to = \"percentage\", \n               values_to = \"mc_nr_qual\") %>% \n  mutate(\n    percentage = as.numeric(str_remove(percentage, \"qual_\"))\n  ) \n```\n:::\n\n\nWe are now going to use `ggplot()`, `geom_density()`, and `fact_grid2()` from [{ggh4x}](https://teunbrand.github.io/ggh4x/). \n\n\n::: {.cell fig.format='svg'}\n\n```{.r .cell-code}\nggplot(data = over_stat_df, aes(x = mc_nr_perc)) + \n  geom_density(aes(fill = species_a)) + \n  geom_vline(data = over_sum, aes(xintercept = mean_mc_nr), \n             colour = \"black\", linewidth = 1) +\n  geom_vline(data = over_sum, aes(xintercept = mc_nr_qual), \n             colour = \"black\", linewidth = 1, linetype = 6) +\n  scale_fill_viridis_d(begin = 0.25, end = 0.75,\n                       option = \"D\", name = \"Species\", \n                       alpha = 0.35) + \n  ggh4x::facet_grid2(species_a ~ species_b, \n                     independent = \"y\",\n                     scales = \"free_y\") + \n  theme_bw() + \n  theme(\n    panel.grid = element_blank(), \n    axis.text = element_text(colour = \"black\"), \n    legend.background = element_blank(),\n    strip.background = element_blank()\n  ) +\n  labs(x = paste(\"Overlap Probability (%)\", \"\\u2013\", \n                 \"Niche Region Size: 95%\"), \n       y = \"p(Percent Overlap | X)\")\n```\n\n::: {.cell-output-display}\n![](nicheROVER_ggplot_files/figure-html/unnamed-chunk-27-1.png){width=100%}\n:::\n:::\n\n\n### Step 10: Estimate overall niche size \nWe are now going to estimate the overall size of the niche for each posterior sample by using the function `niche.size()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nniche_size <- sapply(fish_par, function(spec) {\n  apply(spec$Sigma, 3, niche.size)\n})\n```\n:::\n\n\nWe then need to transform `niche_size` into a data fame for visualization and summary statistics. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nniche_size_df <- niche_size %>% \n  as_tibble() %>% \n  mutate(\n    id = 1:nrow(.)\n  ) %>% \n  pivot_longer(\n    cols = -id, \n    names_to = \"species\", \n    values_to = \"niche_size\"\n  ) %>% \n  mutate(\n    id = 1:nrow(.), \n    species = factor(species,\n                   level = c(\"ARCS\", \"BDWF\", \n                             \"LKWF\", \"LSCS\"))\n  )\n```\n:::\n\n\nWe can calculate the mean niche size, standard deviation, and standard error. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nniche_size_mean <- niche_size_df %>% \n  group_by(species) %>% \n  summarise(\n    mean_niche = round(mean(niche_size), digits = 2), \n    sd_niche = round(sd(niche_size), digits = 2), \n    sem_niche = round(sd(niche_size) / sqrt(n()), digits = 2)\n  )\n```\n:::\n\n\n### Step 11: Plot niche size with {ggplot}\n\nWe will now use `geom_violin()`, `geom_point()` and `geom_errorbar()` to plot the distrubition for niche size for each species.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = niche_size_df) + \n  geom_violin(\n    aes(x = species, y = niche_size),\n    width = 0.2) + \n  geom_point(data = niche_size_mean, aes(x = species, y = mean_niche)) +\n  geom_errorbar(data = niche_size_mean, aes(x = species, \n                                            ymin = mean_niche  - sem_niche, \n                                            ymax = mean_niche  + sem_niche), \n                width = 0.05) +\n  theme_bw(base_size = 15) + \n  theme(panel.grid = element_blank(), \n        axis.text = element_text(colour = \"black\")) + \n  labs(x = \"Species\", \n       y = \"Niche Size\") \n```\n\n::: {.cell-output-display}\n![](nicheROVER_ggplot_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\nNow that we have our niche sizes determined we can report these within our study. \n",
    "supporting": [
      "nicheROVER_ggplot_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}