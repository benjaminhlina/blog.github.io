{
  "hash": "4d941619dd89bcf02ba91cf491924cb2",
  "result": {
    "markdown": "---\ntitle: \"How to use {soapcheckr} to make soap-flim smoothers\"\nauthor: \"Benjamin L. Hlina\"\nimage: \"01_sissabagama_bathymetry_gam.png\"\ndate: \"2023-11-12\"\ncategories: [Generalized Additive Model, Spatial Analysis, Bathymetry]\neditor_options: \n  chunk_output_type: inline\n---\n\n\n\n\n### Our Objectives\n\nThe purpose of this vignette is to demonstrate an effective workflow while using [{soapcheckr}](https://github.com/dill/soap_checker) to efficiently make a soap-film smoother for a Generalized Additive Model (GAM) using the package [{mgcv}](https://cran.r-project.org/web/packages/mgcv/index.html). Soap-film smoothers are really useful when trying to model a variable within a 3-dimensional space (e.g., bathymetry of a lake; [Gavin Simpson Blog Post](https://fromthebottomoftheheap.net/2016/03/27/soap-film-smoothers/)). They can be used for all sorts of data but are quite complex and difficult to setup. [{soapcheckr}](https://github.com/dill/soap_checker) tries to make this process a little easier. This vignette will walk through several different examples using example data sets loaded when loading [{soapcheckr}](https://github.com/dill/soap_checker) and [{mgcv}](https://cran.r-project.org/web/packages/mgcv/index.html). We strongly encourage going through both examples, as the first provides a general background on soap-films within a simple boundary and the second a more complex example within a more complex boundary. \n\n### Example 1: Making a soap-film smoother for a Simple boundary - Ramsay's horseshoe \n\nIf we were wanting to make a soap-film smoother for a boundary that does not have any inner boundaries (e.g., a lake without an island) we can use `{soapcheckr}` to assess our single boundary and the potential knots we want to smooth over. \n\n#### Install [{soapcheckr}](https://github.com/dill/soap_checker)\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('soapcheckr', repos = c('https://benjaminhlina.r-universe.dev',\n                                         'https://cloud.r-project.org'))\n```\n:::\n\n\n#### Load packages \n\nWe will use some data manipulation functions from [{dplyr}](https://dplyr.tidyverse.org/) and some spatial functions from [{sf}](https://r-spatial.github.io/sf/) to first check if we can make a soap-film using [{soapcheckr}](https://github.com/dill/soap_checker) and second to run a GAM using [{mgcv}](https://cran.r-project.org/web/packages/mgcv/index.html) with a soap-film smoother.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  library(broom.mixed)\n  library(fitdistrplus)\n  library(dplyr)\n  library(ggplot2)\n  library(gratia)\n  library(mgcv)\n  library(purrr)\n  library(soapcheckr)\n  library(sf)\n}\n```\n:::\n\n\n#### Check if we can make a soap-film for Ramsey's horseshoe\n\nWe will load Ramsey's horseshoe from [{mgcv}](https://cran.r-project.org/web/packages/mgcv/index.html) and make it a list within a list to sufficiently create the boundary a soap-film smoother needs within a GAM. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfsb <- list(fs.boundary())\n```\n:::\n\n\nWe can then can check the boundary using `soap_check()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(fsb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check ramsays horseshoe-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\n\nWe can see that `soap_check()` returns `TRUE` indicating that we can use this boundary to make a soap-film smoother. `soap_check()` will assess if the boundary supplied, has any overlapping polygons and is in the correct structure for a soap-film smoother to be run in `{mgcv}`. \n\n#### Check if the data and the evenly spaced knots fall within the boundary\n\nSometimes knots are too close to the boundary, resulting with errors from the model that look like this:\n\n```\nError in crunch.knots(ret$G, knots, x0, y0, dx, dy) :\nknot 1 is on or outside boundary\n```\nIt can be tedious and annoying to try to figure out which knots and/or data points are causing issues. The below workflow will demonstrate how to effectively remove knots and/or data points that result in the above error within the GAM. \n\nWe will use `expand.grid()` to create an equally spaced grid of knots. Then we remove knots outside of the boundary using `inSide()` from [{mgcv}](https://cran.r-project.org/web/packages/mgcv/index.html). There still may be knots that are too close to the boundary that will cause for a soap-film smoother to not work. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create knots \nknots <- expand.grid(x = seq(min(fsb[[1]]$x), \n                             max(fsb[[1]]$x), len = 15),\n                     y = seq(min(fsb[[1]]$y) + 0.05,\n                             max(fsb[[1]]$y), len = 10))\nx <- knots$x\ny <- knots$y\n\n# identify the knots that are outside the boundary \nind <- inSide(fsb, x = x, y = y)\n# remove knots outside the boundary \nknots <- knots[ind, ]\n```\n:::\n\n\nWe will also create some fake data to test the model. We will use a uniform distribution to make our test data and a response variable will be created using `fs.test()`. We will use `inSide()` to remove data that fall outside our boundary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(0)\nn <- 600\n\n# Our x and y data \nx <- runif(n) * 5 - 1\ny <- runif(n) * 2 - 1\n\n# create our response variable \nz <- fs.test(x, y, b = 1)\n\n## remove outsiders\n\nind <- inSide(fsb, x = x, y = y) \n\nz <- z + rnorm(n) * 0.3 ## add noise\n\n# create the data we want to model \ndat <- data.frame(z = z[ind],\n                  x = x[ind],\n                  y = y[ind])\n```\n:::\n\n\nHowever, there still may be knots and/or data points that are too close to the boundary.\nOne can go through, one-by-one and remove the offending knots as `crunch.knots()` finds them, but thatâ€™s a bit tedious. Enter `soap_check()` and `autocruncher()`, with the former allowing one to visually check what knots and/or data will causes issues and the latter identifying the index location of the offending knots or data points. If the knot dataframe has column names other than `x` and `y`, we need to supply `soapcheckr()` those names using the arguments `x_name` and `y_name`, respectfully. \n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(fsb, knots = knots)\n#> Warning in soap_check(fsb, knots = knots): Knots 1, 13, 66, 93 are outside the\n#> boundary.\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check our knots-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\nWe can see that there four offending knots that we can subsequently remove using `autocruncher()`. This function will return the indices of the knots that would cause issues. If the knot dataframe has column names other than `x` and `y`, we need supply those column names to the arguments `xname` and `yname`, respectfully. Note that you need to set the `k` and `nmax` arguments in `autocruncher()` to be the same as your planned value in `gam()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncrunch_index <- autocruncher(fsb, knots, k = 30)\ncrunch_index\n#> [1]  1 13 66 93\n\n# remove knots that are problematic\nknots <- knots[-crunch_index, ] \n```\n:::\n\n\nWe can use `soap_check()` again to check if knots all fall within the boundary. \n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(fsb, knots = knots)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check knots with soap_check-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\n\nAnd they do! Congratulations! \n\n#### Check the data \n\nWe can also use `soap_check()` to check if our data falls within the boundary, but `soap_check()` only cares about the coordinates you want to supply the soap-film. So first we will create a secondary dataframe that has the response variable, `z`, removed from it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_2 <- dat[, 2:3]\nsoap_check(fsb, data = dat_2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check data with soapcheck-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\n\nCongrats we can see our data doesn't fall too closely to boundary and is within the boundary. \n\n#### Run the model \n\nBetween data, knots, and boundary all column names must be the same for the model to work. Prior to running confirm that they are all the same. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- gam(z ~ s(x, y, k = 30 , bs = \"so\",\n               xt = list(bnd = fsb)),\n         knots = knots, \n         data = dat)\n```\n:::\n\nNext, check main effects of the model. \n\n::: {.cell}\n\n```{.r .cell-code}\nanova(m)\n```\n:::\n\nThen visually check the model effects using `draw()` from [{gratia}](https://gavinsimpson.github.io/gratia/)\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw(m)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/draw model effects-1.png){width=672}\n:::\n:::\n\nLastly, check the model fit using `appraise()` from [{gratia}](https://gavinsimpson.github.io/gratia/)\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise(m)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check model fit-1.png){width=672}\n:::\n:::\n\nWe can see the model fits well and is appropriate for the example data. Now that you've walked through a simple boundary, we will go to a more complex boundary example. More than likely you will be working with a complex boundary. The below walk through can be applied to a simple boundary as well. \n\n### Example 2: Making a soap-film smoother for a more complex boundary.\nMore than likely you will have your boundary as a `sf` object. To convert that `sf` object into the boundary list needed by {mgcv} and {soapcheckr}, we will have to do some conversions. First that boundary might not be in the correct coordinate reference system (CRS). To create a soap-film smoother we need to use a CRS that for one unit change in either dimension (i.e., x and y) are equal. For example using latitude and longitude in decimal degrees with a WGS 84 projection will not work because one unit of change in either direction is not equal. Therefore, we will need to use a CRS that is based on equal units. The most common CRS to do this is UTMs, if the boundary is already in UTMs great, if not see below.\n\n#### Convert CRS \nThe more complex boundary that we will load through {soapcheckr} is a lake from northern Wisconsin, Sissabagama Lake. I grew up fishing on this lake which is where initially became interested and passionate about aquatic ecosystems, fish, and fisheries management. This lake falls within UTM zone 15N that can also be refereed to as ESPG: 32615, but your boundary will more than likely fall into a different CRS. You can look up ESPG codes [here](https://epsg.io/). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsissabagama_lake_sf <- sissabagama_lake_sf %>% \n  st_transform(crs = 32615)\n```\n:::\n\n\n#### Convert to boundary list \nWe need to create the list of lists of the boundaries from the `sf` object that we will supply to the soap-film smoother. \n\nOur example lake has a `geometry` column that is a `POLYGON`. We need to be able to split that into each polygon (i.e., islands) that we will create the boundary list from. We can do this by first casting our `geometry` into `MULTIPOINT` and assigning each `MULTIPOINT` row an ID value. \n\n::: {.cell}\n\n```{.r .cell-code}\nbnd_pt_sf <- sissabagama_lake_sf %>%\n  dplyr::select(geometry) %>%\n  st_cast(\"MULTIPOINT\") %>%\n  mutate(\n    id = 1:nrow(.)\n  )\n```\n:::\n\n\nNext we will split our `sf` object and iterate over each `MULTIPOINT` geometry to first cast to individual `POINT` geometry and extract each `x` and `y` coordinates. It is important in this step that the names of the coordinates are `x` and `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbnd_pt <- bnd_pt_sf %>%\n  split(.$id) %>%\n  purrr::map(~ st_cast(.x, \"POINT\") %>%\n               mutate(\n                 x = st_coordinates(.)[,\"X\"],\n                 y = st_coordinates(.)[,\"Y\"]\n               ) %>%\n               st_drop_geometry() %>% \n               dplyr::select(-id)\n  )\n```\n:::\n\n\nWe now have a list of dataframes split by each polygon's x and y coordinates that have had the `id` column removed. We then need to create a vector that is `id` number of each polygon. In this case it's 1-5, we can use `length()` of our list o dataframes to easily create the end of our numerical vector. \n\nWe will then iterate over our list and bind them all together to get our lists and lists of our polygon boundaries. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnr <- 1:length(bnd_pt)\n\nsissabagama_bnd_ls <- lapply(nr, function(n) as.list.data.frame(bnd_pt[[n]]))\n```\n:::\n\n\n#### Check if the boundary list works \n\nWe will check the boundary list using `soap_check()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(sissabagama_bnd_ls)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check more complex boundary-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\n`soap_check` returns back `TRUE` so our more complex boundary will work for our soap-film smoother. One thing that I've always loved about this lake is how it looks like person! \n\n#### Make knots for a more complex boundary using [{sf}](https://r-spatial.github.io/sf/)\n\nWe can use `st_make_grid()` to create a grid of equally spaced points across the boundary box of our example `sf` object of Sissabagama Lake. Remember a soap-film smoother needs equally spaced knots to smooth over. Our `sf` object is in UTMs which is great becasue then each grid point in this case is 200 m away from each other. Depending on the size of the boundary and system you can change 200 to whatever value makes sense (e.g., large system, further spaced knots, small system, closer spaced knots/this is suggestion but do whatever makes sense).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_grid <- sissabagama_lake_sf %>%\n  st_make_grid(cellsize = 200, square = TRUE, what = \"centers\") %>%\n  st_as_sf() \n\nst_geometry(lake_grid) <- \"geometry\"\n```\n:::\n\n\nWe will then remove all the knots that fall outside the boundary by using `st_intersection()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_intesects <- st_intersection(sissabagama_lake_sf, lake_grid)\n```\n:::\n\n\nNext we will create our knot dataframe by extracting the lon and lat of each point and then dropping the `geometry` column and selecting our `lon` and `lat` columns. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_knots <- lake_intesects %>%\n  mutate(\n    lon = st_coordinates(.)[,\"X\"],\n    lat = st_coordinates(.)[,\"Y\"]\n  ) %>%\n  st_drop_geometry() %>%\n  as.data.frame() %>%\n  dplyr::select(lon, lat)\n```\n:::\n\n\nNow that we have our knots we can check to see if there are any knots that fall too close to the boundary using `soap_check()`\n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(sissabagama_bnd_ls, knots = lake_knots, \n           x_name = \"lon\", y_name = \"lat\")\n#> Warning in soap_check(sissabagama_bnd_ls, knots = lake_knots, x_name = \"lon\", :\n#> Knots 42, 63, 68 are outside the boundary.\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check knots using soap_check-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\n\n\nWe can see that there are a few knots that are too close to the boundary. We can remove them using `autocruncher()`\n\n::: {.cell}\n\n```{.r .cell-code}\ncrunch_ind <- autocruncher(sissabagama_bnd_ls, lake_knots, \n                           xname = \"lon\", yname = \"lat\")\ncrunch_ind\n#> [1] 42 63 68\n\n# remove knots that are problematic\nlake_knots <- lake_knots[-crunch_ind, ] \n```\n:::\n\nNow that those knots have been removed we can recheck our knots using `soap_check()`\n\n::: {.cell}\n\n```{.r .cell-code}\nsoap_check(sissabagama_bnd_ls, knots = lake_knots, \n           x_name = \"lon\", y_name = \"lat\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/recheck knots-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\nCongratulations! We have knots and a boundary that we can supply our model. \n\n#### Sissabagama example dataset \n\nWe will bring our sampled depths at given locations for Sissabagama lake. This data was generated by referencing the contour map supplied by the [Wisconsin DNR](https://apps.dnr.wi.gov/lakes/lakepages/LakeDetail.aspx?wbic=2393500). We will first remove depth to check if the data points all fall within our boundary using `soap_check()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsissabagama_bath_pt <- sissabagama_bath %>% \n  dplyr::select(-depth)\n\nsoap_check(sissabagama_bnd_ls, data = sissabagama_bath_pt)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/remove depth for soap_check-1.png){width=672}\n:::\n\n```\n#> [1] TRUE\n```\n:::\n\nThen we will assess the distribution of the data to determine which distribution the model should use to fit the data to. We will use functions from [{fitdistrplus}](https://cran.r-project.org/web/packages/fitdistrplus/index.html). \n\n::: {.cell}\n\n```{.r .cell-code}\ndepths <- sissabagama_bath$depth\ndescdist(depths)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check skewness and kurtosis-1.png){width=672}\n:::\n\n```\n#> summary statistics\n#> ------\n#> min:  3   max:  48 \n#> median:  15 \n#> mean:  15.29438 \n#> estimated sd:  9.983594 \n#> estimated skewness:  0.7078068 \n#> estimated kurtosis:  2.964066\n```\n:::\n\nSkewness and kurtosis of our example data indicates that a model using a Gamma error distribution will likely fit. \n\n::: {.cell}\n\n```{.r .cell-code}\nfit_gamma <- fitdist(depths, distr = \"gamma\", method = \"mme\")\nplot(fit_gamma)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check distr-1.png){width=672}\n:::\n:::\n\n\nWe can see the depth data will likely fit a Gamma error distribution and therefore our GAM will use a Gamma error distribution.\n\n#### Run the model \nPrior to running our GAM with a soap-film smoother we need to add one last thing to our boundary list. We need to add the variable `f` to every boundary polygon within our boundary list. This variable indicates to the soap-film smoother that our response variable is `0` right at the boundary, otherwise the soap-film smoother does not know what to do when it hits the boundary. \n\n::: {.cell}\n\n```{.r .cell-code}\nnames(lake_knots) <- c(\"x\", \"y\")\n\nsissabagama_bnd_ls <- lapply(nr,\n                             function(n)\n                               sissabagama_bnd_ls[[n]] <- c(\n                                 sissabagama_bnd_ls[[n]],\n                                 list(f = rep(0, length(sissabagama_bnd_ls[[n]]$x))\n                                 )\n                               )\n)\n```\n:::\n\nWe can now successfully run our GAM with a soap-film smoother.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- gam(depth ~ s(x, y,\n                    bs = \"so\",\n                    xt = list(bnd = sissabagama_bnd_ls)),\n          family = Gamma(link = \"identity\"),\n          knots = lake_knots,\n          data = sissabagama_bath)\n```\n:::\n\n\nWe can evaluate the main of the model using `anova()`\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(m1)\n#> \n#> Family: Gamma \n#> Link function: identity \n#> \n#> Formula:\n#> depth ~ s(x, y, bs = \"so\", xt = list(bnd = sissabagama_bnd_ls))\n#> \n#> Approximate significance of smooth terms:\n#>          edf Ref.df     F p-value\n#> s(x,y) 57.47  76.00 16.51  <2e-16\n```\n:::\n\n\nNext we can evaluate partial effects of the model using `summary()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(m1)\n#> \n#> Family: Gamma \n#> Link function: identity \n#> \n#> Formula:\n#> depth ~ s(x, y, bs = \"so\", xt = list(bnd = sissabagama_bnd_ls))\n#> \n#> Parametric coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)   2.8408     0.2074    13.7   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Approximate significance of smooth terms:\n#>          edf Ref.df     F p-value    \n#> s(x,y) 57.47     76 16.51  <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> R-sq.(adj) =  0.786   Deviance explained = 76.8%\n#> GCV = 0.15835  Scale est. = 0.12696   n = 445\n```\n:::\n\n\nWe can evaluate the partial effects of the model using `draw()` from `{gratia}`\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw(m1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check partial effects-1.png){width=672}\n:::\n:::\n\nWe can evaluate how well the model fit is to the data using `appraise()` also from `{gratia}`\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise(m1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/check model fit for m1-1.png){width=672}\n:::\n:::\n\n\n#### Plot our predicted results \n\nWe will first create a 10 m grid from our `sf` object of our boundary. Depending on the size of the boundary you can change the grid size distance to whatever distance makes sense (i.e., if the system is large you may want to increase the `cellsize`). \n\n::: {.cell}\n\n```{.r .cell-code}\nlake_pred <- sissabagama_lake_sf %>%\n  st_make_grid(cellsize = 10, square = TRUE, what = \"centers\") %>% \n  st_as_sf() \nst_geometry(lake_pred) <- \"geometry\"\n```\n:::\n\nAfter creating the grid that we will predict values from we will need to remove any points that fall outside our polygon boundary. \n\n::: {.cell}\n\n```{.r .cell-code}\nlake_pred <- st_intersection(lake_pred, sissabagama_lake_sf) %>% \n  dplyr::select(geometry)\n```\n:::\n\nThen we extract latitude and longitude and convert the `sf` object into a dataframe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlake_pred_df <- lake_pred %>% \n  mutate(\n    x = st_coordinates(.)[,\"X\"], \n    y = st_coordinates(.)[,\"Y\"], \n  ) %>% \n  st_drop_geometry()\n```\n:::\n\nWe then can use the function `augment()` from the package [{broom.mixed}](https://cran.r-project.org/web/packages/broom.mixed/index.html) to predict depth of the lake at a given latitude and longitude.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred <- augment(m1, newdata = lake_pred_df)\npred <- pred %>% \n  mutate(\n    lower = .fitted - 1.96 * .se.fit,\n    higher = .fitted + 1.96 * .se.fit\n  )\n```\n:::\n\n\nLastly, we can visualize our predicted depths to create a bathymetic map of the lake using `ggplot()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_raster(data = pred, aes(x = x, y = y, fill = .fitted)) +\n  geom_sf(data = sissabagama_lake_sf, fill = NA, colour = \"black\") +\n  scale_fill_viridis_c(name = \"Depth (m)\",\n                       trans = \"reverse\",\n                       breaks = rev(seq(0, 60, 15))\n  ) + \n  theme_void(\n    base_size = 15\n  ) + \n  theme(\n    legend.background = element_blank(),\n    legend.position = c(0.98, 0.82),\n  ) + \n  guides(fill = guide_colourbar(\n    frame.linewidth = 0.3,\n    ticks.colour = 'black', \n    frame.colour = 'black')) + \n  labs(x = \"Longitude\", \n       y = \"Latitude\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot our predicted depths using ggplot-1.png){width=672}\n:::\n:::\n\n\nCongratulations! We have made a soap-film GAM that takes in account the boundaries within the lake to estimate the bathymetry of the lake. For this example I used bathymetry, but you can use this workflow to model any type of variable (e.g., fish and/or animal movement/acceleration, wind speed, water quality, ect.)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}